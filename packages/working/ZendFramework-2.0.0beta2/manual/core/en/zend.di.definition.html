<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>5.3. Zend\Di Definition</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.di.html" title="Chapter 5. Zend\Di">
<link rel="prev" href="zend.di.quickstart.html" title="5.2. Zend\Di Quickstart">
<link rel="next" href="zend.di.instancemanager.html" title="5.4. Zend\Di InstanceManager">
<link rel="part" href="introduction.html" title="Part I. Introduction to Zend Framework">
<link rel="chapter" href="introduction.overview.html" title="Chapter 1. Overview">
<link rel="chapter" href="introduction.installation.html" title="Chapter 2. Installation">
<link rel="part" href="learning.html" title="Part II. Learning Zend Framework">
<link rel="chapter" href="learning.di.html" title="Chapter 3. Learning Dependency Injection">
<link rel="article" href="ar01.html" title="">
<link rel="part" href="reference.html" title="Part III. Zend Framework Reference">
<link rel="chapter" href="zend.cache.html" title="Chapter 4. Zend\Cache">
<link rel="chapter" href="zend.di.html" title="Chapter 5. Zend\Di">
<link rel="chapter" href="zend.event-manager.html" title="Chapter 6. Zend\EventManager">
<link rel="chapter" href="zend.http.html" title="Chapter 7. Zend_Http">
<link rel="chapter" href="zend.loader.html" title="Chapter 8. Zend_Loader">
<link rel="chapter" href="zend.mail.html" title="Chapter 9. Zend\Mail">
<link rel="chapter" href="zend.module.html" title="Chapter 10. Zend\Module">
<link rel="chapter" href="zend.mvc.html" title="Chapter 11. Zend\Mvc">
<link rel="chapter" href="zend.uri.html" title="Chapter 12. Zend_Uri">
<link rel="appendix" href="copyrights.html" title="Appendix A. Copyright Information">
<link rel="subsection" href="zend.di.definition.html#zend.di.definition.definitionlist" title="5.3.1. DefinitionList">
<link rel="subsection" href="zend.di.definition.html#zend.di.definition.runtimedefinition" title="5.3.2. RuntimeDefinition">
<link rel="subsection" href="zend.di.definition.html#zend.di.definition.compilerdefinition" title="5.3.3. CompilerDefinition">
<link rel="subsection" href="zend.di.definition.html#zend.di.definition.classdefinition" title="5.3.4. ClassDefinition">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">5.3. Zend\Di Definition</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.di.quickstart.html">Prev</a> </td>
<th width="60%" align="center">Chapter 5. Zend\Di</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.di.instancemanager.html">Next</a>
</td>
</tr>
</table></div>
<div class="section" title="5.3. Zend\Di Definition">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.di.definition"></a>5.3. Zend\Di Definition</h2></div></div></div>
<p>
        Definitions are the place where Zend\Di attempts to understand
        the structure of the code it is attempting to wire.  This means
        that if you've written non-ambiguous, clear and concise code;
        Zend\Di has a very good chance of understanding how to wire things
        up without much added complexity.
    </p>
<div class="section" title="5.3.1. DefinitionList">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.di.definition.definitionlist"></a>5.3.1. DefinitionList</h3></div></div></div>
<p>
            Definitions are introduced to the Zend\Di\Di object through
            a definition list implemented as Zend\Di\DefinitionList (SplDoublyLinkedList).
            Order is important.  Definitions in the front of the list will be consulted
            on a class before definitions at the end of the list.
        </p>
<p>
            Note: Regardless of what kind of Definition strategy you decide to use,
            it is important that your autoloaders are already setup and ready to use.
        </p>
</div>
<div class="section" title="5.3.2. RuntimeDefinition">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.di.definition.runtimedefinition"></a>5.3.2. RuntimeDefinition</h3></div></div></div>
<p>
            The default DefinitionList instantiated by Zend\Di\Di, when no other
            DefinitionList is provided, has as Definition\RuntimeDefinition baked-in.
            The RuntimeDefinition will respond to query's about classes by using Reflection.
            This Runtime definitions uses any available information inside methods: their
            signature, the names of parameters, the type-hints of the parameters, and the
            default values to determine if something is optional or required when making a
            call to that method.  The more explicit you can be in your method naming and
            method signatures, the easier of a time Zend\Di\Definition\RuntimeDefinition
            will have determining the structure of your code.
        </p>
<p>
            This is what the constructor of a RuntimeDefinition looks like:
        </p>
<pre class="programlisting">
public function __construct(IntrospectionStrategy $introspectionStrategy = null, array $explicitClasses = null)
{
    $this-&gt;introspectionStrategy = ($introspectionStrategy) ?: new IntrospectionStrategy();
    if ($explicitClasses) {
        $this-&gt;setExplicitClasses($explicitClasses);
    }
}
</pre>
<p>
            The IntrospectionStrategy object is an object that determines the rules, or
            guidelines, for how the RuntimeDefinition will introspect information about your classes.
            Here are the things it knows how to do:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    Whether or not to use Annotations (Annotations are expensive and off by default,
                    read more about these in the Annotations section)
                </p></li>
<li class="listitem"><p>
                    Which method names to include in the introspection, by default, the pattern
                    /^set[A-Z]{1}\w*/ is registered by default, this is a list of patterns.
                </p></li>
<li class="listitem"><p>
                    Which interface names represent the interface injection pattern.  By default,
                    the pattern /\w*Aware\w*/ is registered, this is a list of patterns.
                </p></li>
</ul></div>
<p>
            The constructor for the IntrospectionStrategy looks like this:
        </p>
<pre class="programlisting">
public function __construct(AnnotationManager $annotationManager = null)
{
    $this-&gt;annotationManager = ($annotationManager) ?: $this-&gt;createDefaultAnnotationManager();
}
</pre>
<p>
            This goes to say that an AnnotationManager is not required, but if you wish to create
            a special AnnotationManager with your own annotations, and also wish to extend the
            RuntimeDefinition to look for these special Annotations, this is the place to do it.
        </p>
<p>
            The RuntimeDefinition also can be used to look up either all classes (implicitly,
            which is default), or explicitly look up for particular pre-defined classes.  This
            is useful when your strategy for inspecting one set of classes might differ from
            those of another strategy for another set of classes.  This can be achieved by using
            the setExplictClasses() method or by passing a list of classes as a second argument
            to the constructor of the RuntimeDefinition.
        </p>
</div>
<div class="section" title="5.3.3. CompilerDefinition">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.di.definition.compilerdefinition"></a>5.3.3. CompilerDefinition</h3></div></div></div>
<p>
            The CompilerDefinition is very much similar in nature to the RuntimeDefinition
            with the exception that it can be seeded with more information for the purposes
            of "compiling" a definition.  This is useful when you do not want to be making
            all those (sometimes expensive) calls to reflection and the annotation scanning
            system during the request of your application.  By using the compiler, a definition
            can be created and written to disk to be used during a request, as opposed to the
            task of scanning the actual code.
        </p>
<p>
            For example, let's assume we want to create a script that will create definitions
            for some of our library code:
        </p>
<pre class="programlisting">
// in "package name" format
$components = array(
    'My_MovieApp',
    'My_OtherClasses',
);

foreach ($components as $component) {
    $diCompiler = new Zend\Di\Definition\CompilerDefinition;
    $diCompiler-&gt;addDirectory('/path/to/classes/' . str_replace('_', '/', $component));

    $diCompiler-&gt;compile();
    file_put_contents(
        __DIR__ . '/../data/di/' . $component . '-definition.php',
        '&lt;?php return ' . var_export($diCompiler-&gt;toArrayDefinition()-&gt;toArray(), true) . ';'
    );
}
</pre>
<p>
            This will create a couple of files that will return an array of the definition
            for that class.  To utilize this in an application, the following code will suffice:
        </p>
<pre class="programlisting">
protected function setupDi(Application $app)
{
    $definitionList = new DefinitionList(array(
        new Definition\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_MovieApp-definition.php'),
        new Definition\ArrayDefinition(include __DIR__ . '/path/to/data/di/My_OtherClasses-definition.php'),
        $runtime = new Definition\RuntimeDefinition(),
    ));
    $di = new Di($definitionList, null, new Configuration($this-&gt;config-&gt;di));
    $di-&gt;instanceManager()-&gt;addTypePreference('Zend\Di\Locator', $di);
    $app-&gt;setLocator($di);
}
</pre>
<p>
            The above code would more than likely go inside your application's or module's bootstrap
            file.  This represents the simplest and most performant way of configuring your DiC for usage.
        </p>
</div>
<div class="section" title="5.3.4. ClassDefinition">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.di.definition.classdefinition"></a>5.3.4. ClassDefinition</h3></div></div></div>
<p>
            The idea behind using a ClassDefinition is two-fold.  First, you may want to override some
            information inside of a RuntimeDefinition.  Secondly, you might want to simply define your
            complete class's definition with an xml, ini, or php file describing the structure.  This
            class definition can be fed in via Configuration or by directly instantiating and
            registering the Definition with the DefinitionList.
        </p>
<p>Todo - example</p>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.di.quickstart.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.di.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.di.instancemanager.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">5.2. Zend\Di Quickstart </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> 5.4. Zend\Di InstanceManager</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
