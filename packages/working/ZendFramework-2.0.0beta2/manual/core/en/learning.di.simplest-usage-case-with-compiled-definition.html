<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>5. Simplest usage case with Compiled Definition</title>
<link rel="stylesheet" href="dbstyle.css" type="text/css">
<meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="ar01.html" title="">
<link rel="prev" href="learning.di.simplest-usage-case-without-type-hints.html" title="4. Simplest Usage Case Without Type-hints">
<link rel="next" href="learning.di.creating-a-precompiled-definition-for-others-to-use.html" title="6. Creating a precompiled definition for others to use">
<link rel="part" href="introduction.html" title="Part I. Introduction to Zend Framework">
<link rel="chapter" href="introduction.overview.html" title="Chapter 1. Overview">
<link rel="chapter" href="introduction.installation.html" title="Chapter 2. Installation">
<link rel="part" href="learning.html" title="Part II. Learning Zend Framework">
<link rel="chapter" href="learning.di.html" title="Chapter 3. Learning Dependency Injection">
<link rel="article" href="ar01.html" title="">
<link rel="part" href="reference.html" title="Part III. Zend Framework Reference">
<link rel="chapter" href="zend.cache.html" title="Chapter 4. Zend\Cache">
<link rel="chapter" href="zend.di.html" title="Chapter 5. Zend\Di">
<link rel="chapter" href="zend.event-manager.html" title="Chapter 6. Zend\EventManager">
<link rel="chapter" href="zend.http.html" title="Chapter 7. Zend_Http">
<link rel="chapter" href="zend.loader.html" title="Chapter 8. Zend_Loader">
<link rel="chapter" href="zend.mail.html" title="Chapter 9. Zend\Mail">
<link rel="chapter" href="zend.module.html" title="Chapter 10. Zend\Module">
<link rel="chapter" href="zend.mvc.html" title="Chapter 11. Zend\Mvc">
<link rel="chapter" href="zend.uri.html" title="Chapter 12. Zend_Uri">
<link rel="appendix" href="copyrights.html" title="Appendix A. Copyright Information">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">5. Simplest usage case with Compiled Definition</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="learning.di.simplest-usage-case-without-type-hints.html">Prev</a> </td>
<th width="60%" align="center"></th>
<td width="20%" align="right"> <a accesskey="n" href="learning.di.creating-a-precompiled-definition-for-others-to-use.html">Next</a>
</td>
</tr>
</table></div>
<div class="section" title="5. Simplest usage case with Compiled Definition">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="learning.di.simplest-usage-case-with-compiled-definition"></a>5. Simplest usage case with Compiled Definition</h2></div></div></div>
<p>
    Without going into the gritty details, as you might expect, PHP at
    its core is not DI friendly. Out-of-the-box, the
    <code class="literal">DependencyInjector</code> uses a
    <code class="literal">RuntimeDefinition</code> which does all class map
    resolution via PHP's <code class="literal">Reflection</code> extension. Couple
    that with the fact that PHP does not have a true application layer
    capable of storing objects in-memory between requests, and you get a
    recipe that is less performant than similar solutions you'll find in
    Java and .Net (where there is an application layer with in-memory
    object storage.)
  </p>
<p>
    To mitigate this shortcoming, <code class="literal">Zend\Di</code> has several
    features built in capable of pre-compiling the most expensive tasks
    that surround dependency injection. It is worth noting that the
    <code class="literal">RuntimeDefition</code>, which is used by default, is the
    <span class="strong"><strong>only</strong></span> definition that does lookups
    on-demand. The rest of the <code class="literal">Definition</code> objects are
    capable of being aggregated and stored to disk in a very performant
    way.
  </p>
<p>
    Ideally, 3rd party code will ship with a pre-compiled
    <code class="literal">Definition</code> that will describe the various
    relationships and parameter/property needs of each class that is to
    be instantiated. This <code class="literal">Definition</code> would have been
    built as part of some deployment or packaging task by this 3rd
    party. When this is not the case, you can create these
    <code class="literal">Definitions</code> via any of the
    <code class="literal">Definition</code> types provided with the exception of
    the <code class="literal">RuntimeDefinition</code>. Here is a breakdown of the
    job of each definition type:
  </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
        <code class="literal">AggregateDefinition</code> - Aggregates multiple
        definitions of various types. When looking for a class, it looks
        it up in the order the definitions were provided to this
        aggregate.
      </p></li>
<li class="listitem"><p>
        <code class="literal">ArrayDefinition</code> - This definition takes an
        array of information and exposes it via the interface provided
        by <code class="literal">Zend\Di\Definition</code> suitable for usage by
        <code class="literal">DependencyInjector</code> or an
        <code class="literal">AggregateDefinition</code>
      </p></li>
<li class="listitem"><p>
        <code class="literal">BuilderDefinition</code> - Creates a definition
        based on an object graph consisting of various
        <code class="literal">Builder\PhpClass</code> objects and
        <code class="literal">Builder\InectionMethod</code> objects that describe
        the mapping needs of the target codebase and …
      </p></li>
<li class="listitem"><p>
        <code class="literal">Compiler</code> - This is not actually a definition,
        but produces an <code class="literal">ArrayDefinition</code> based off of
        a code scanner
        (<code class="literal">Zend\Code\Scanner\DirectoryScanner</code> or
        <code class="literal">Zend\Code\Scanner\FileScanner</code>).
      </p></li>
</ul></div>
<p>
    The following is an example of producing a definition via a
    <code class="literal">DirectoryScanner</code>:
  </p>
<pre class="programlisting">
$compiler = new Zend\Di\Definition\Compiler();
$compiler-&gt;addCodeScannerDirectory(
    new Zend\Code\Scanner\ScannerDirectory('path/to/library/My/')
);
$definition = $compiler-&gt;compile();
</pre>
<p>
    This definition can then be directly used by the
    <code class="literal">DependencyInjector</code> (assuming the above
    <code class="literal">A, B, C</code> scenario was actually a file per class on
    disk):
  </p>
<pre class="programlisting">
$di = new Zend\Di\DependencyInjector;
$di-&gt;setDefinition($definition);
$di-&gt;getInstanceManager()-&gt;setProperty('My\A', 'username', 'foo');
$di-&gt;getInstanceManager()-&gt;setProperty('My\A', 'password', 'bar');
$c = $di-&gt;get('My\C');
</pre>
<p>
    One strategy for persisting these compiled definitions would be the
    following:
  </p>
<pre class="programlisting">
if (!file_exists(__DIR__ . '/di-definition.php') &amp;&amp; $isProduction) {
    $compiler = new Zend\Di\Definition\Compiler();
    $compiler-&gt;addCodeScannerDirectory(
        new Zend\Code\Scanner\ScannerDirectory('path/to/library/My/')
    );
    $definition = $compiler-&gt;compile();
    file_put_contents(
        __DIR__ . '/di-definition.php', 
        '&lt;?php return ' . var_export($definition-&gt;toArray(), true) . ';'
    );
} else {
    $definition = new Zend\Di\Definition\ArrayDefinition(
        include __DIR__ . '/di-definition.php'
    );
}

// $definition can now be used; in a production system it will be written 
// to disk.
</pre>
<p>
    Since <code class="literal">Zend\Code\Scanner</code> does not include files,
    the classes contained within are not loaded into memory. Instead,
    <code class="literal">Zend\Code\Scanner</code> uses tokenization to determine
    the structure of your files. This makes this suitable to use this
    solution during development and within the same request as any one
    of your application's dispatched actions.
  </p>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="learning.di.simplest-usage-case-without-type-hints.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="ar01.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="learning.di.creating-a-precompiled-definition-for-others-to-use.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">4. Simplest Usage Case Without Type-hints </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> 6. Creating a precompiled definition for others to use</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
