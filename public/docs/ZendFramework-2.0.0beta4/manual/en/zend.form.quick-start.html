<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>9.2. Zend\Form Quick Start</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.form.html" title="Chapter 9. Zend_Form">
<link rel="prev" href="zend.form.html" title="Chapter 9. Zend_Form">
<link rel="next" href="zend.http.html" title="Chapter 10. Zend_Http">
<link rel="part" href="introduction.html" title="Part I. Introduction to Zend Framework">
<link rel="chapter" href="introduction.overview.html" title="Chapter 1. Overview">
<link rel="chapter" href="introduction.installation.html" title="Chapter 2. Installation">
<link rel="part" href="learning.html" title="Part II. Learning Zend Framework">
<link rel="article" href="learning.di.html" title="Learning Dependency Injection">
<link rel="part" href="reference.html" title="Part III. Zend Framework Reference">
<link rel="chapter" href="zend.cache.html" title="Chapter 3. Zend\Cache">
<link rel="chapter" href="zend.config.html" title="Chapter 4. Zend_Config">
<link rel="chapter" href="zend.crypt.html" title="Chapter 5. Zend_Crypt">
<link rel="chapter" href="zend.db.html" title="Chapter 6. Zend_Db">
<link rel="chapter" href="zend.di.html" title="Chapter 7. Zend\Di">
<link rel="chapter" href="zend.event-manager.html" title="Chapter 8. Zend\EventManager">
<link rel="chapter" href="zend.form.html" title="Chapter 9. Zend_Form">
<link rel="chapter" href="zend.http.html" title="Chapter 10. Zend_Http">
<link rel="chapter" href="zend.input-filter.html" title="Chapter 11. Zend\InputFilter">
<link rel="chapter" href="zend.ldap.html" title="Chapter 12. Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="Chapter 13. Zend_Loader">
<link rel="chapter" href="zend.mail.html" title="Chapter 14. Zend\Mail">
<link rel="chapter" href="zend.module-manager.html" title="Chapter 15. Zend\ModuleManager">
<link rel="chapter" href="zend.mvc.html" title="Chapter 16. Zend\Mvc">
<link rel="chapter" href="zend.service-manager.html" title="Chapter 17. Zend\ServiceManager">
<link rel="chapter" href="zend.stdlib.html" title="Chapter 18. Zend\Stdlib">
<link rel="chapter" href="zend.uri.html" title="Chapter 19. Zend_Uri">
<link rel="chapter" href="zend.view.html" title="Chapter 20. Zend_View">
<link rel="appendix" href="copyrights.html" title="Appendix A. Copyright Information">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">9.2. Zend\Form Quick Start</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.form.html">Prev</a> </td>
<th width="60%" align="center">Chapter 9. Zend_Form</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.http.html">Next</a>
</td>
</tr>
</table></div>
<div class="section" title="9.2. Zend\Form Quick Start">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.form.quick-start"></a>9.2. Zend\Form Quick Start</h2></div></div></div>
<p>
        Forms are relatively easy to create. At the bare minimum, each element or fieldset requires
        a name; typically, you'll also provide some attributes to hint to the view layer how it
        might render the item. The form itself will also typically compose an <code class="classname"><a class="classname" href="zend.input-filter.html" title="Chapter 11. Zend\InputFilter">InputFilter</a></code> -- which you can also conveniently
        create directly in the form via a factory. Individual elements can hint as to what defaults
        to use when generating a related input for the input filter.
    </p>
<p>
        Form validation is as easy as providing an array of data to the
        <code class="methodname">setData()</code> method. If you want to simplify your work even more, you
        can bind an object to the form; on successful validation, it will be populated from the
        validated values.
    </p>
<div class="example">
<a name="zend.form.quick-start.programmatic"></a><p class="title"><b>Example 9.1. Programmatic Form Creation</b></p>
<div class="example-contents">
<p>
            If nothing else, you can simply start creating elements, fieldsets, and forms and wiring
            them together.
        </p>
<pre class="programlisting">
use Zend\Captcha;
use Zend\Form\Element;
use Zend\Form\Fieldset;
use Zend\Form\Form;
use Zend\InputFilter\Input;
use Zend\InputFilter\InputFilter;

$name = new Element('name');
$name-&gt;setAttributes(array(
    'type'  =&gt; 'text',
    'label' =&gt; 'Your name',
));

$email = new Element('email');
$email-&gt;setAttributes(array(
    'type'  =&gt; 'email',
    'label' =&gt; 'Your email address',
));

$subject = new Element('subject');
$subject-&gt;setAttributes(array(
    'type'  =&gt; 'text',
    'label' =&gt; 'Subject',
));

$message = new Element('message');
$message-&gt;setAttributes(array(
    'type'  =&gt; 'textarea',
    'label' =&gt; 'Message',
));

$captcha = new Element\Captcha('captcha');
$captcha-&gt;setCaptcha(new Captcha\Dumb());
$captcha-&gt;setAttributes(array(
    'label' =&gt; 'Please verify you are human',
));

$csrf = new Element\Csrf('security');

$submit = new Element('send');
$submit-&gt;setAttributes(array(
    'type'  =&gt; 'submit',
    'label' =&gt; 'Send',
));


$form = new Form('contact');
$form-&gt;add($name);
$form-&gt;add($email);
$form-&gt;add($subject);
$form-&gt;add($message);
$form-&gt;add($captcha);
$form-&gt;add($csrf);
$form-&gt;add($send);

$nameInput = new Input('name');
// configure input... and all others
$inputFilter = new InputFilter();
// attach all inputs

$form-&gt;setInputFilter($inputFilter);
</pre>
<p>
            As a demonstration of fieldsets, let's alter the above slightly. We'll create two
            fieldsets, one for the sender information, and another for the message details.
        </p>
<pre class="programlisting">
$sender = new Fieldset('sender');
$sender-&gt;add($name);
$sender-&gt;add($email);

$details = new Fieldset('details');
$details-&gt;add($subject);
$details-&gt;add($message);

$form = new Form('contact');
$form-&gt;add($sender);
$form-&gt;add($details);
$form-&gt;add($captcha);
$form-&gt;add($csrf);
$form-&gt;add($send);
</pre>
<p>
            Regardles of approach, as you can see, this can be tedious.
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.factory"></a><p class="title"><b>Example 9.2. Creation via Factory</b></p>
<div class="example-contents">
<p>
            You can create the entire form, and input filter, using the
            <code class="classname">Factory</code>. This is particularly nice if you want to store your
            forms as pure configuration; you can simply pass the configuration to the factory and be
            done.
        </p>
<pre class="programlisting">
use Zend\Form\Factory;
$factory = new Factory();
$form    = $factory-&gt;createForm(array(
    'hydrator' =&gt; 'Zend\Stdlib\Hydrator\ArraySerializable'
    'elements' =&gt; array(
        array(
            'name' =&gt; 'name',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Your name',
            ),
        ),
        array(
            'name' =&gt; 'email',
            'attributes' =&gt; array(
                'type'  =&gt; 'email',
                'label' =&gt; 'Your email address',
            ),
        ),
        array(
            'name' =&gt; 'subject',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Subject',
            ),
        ),
        array(
            'name' =&gt; 'message',
            'attributes' =&gt; array(
                'type'  =&gt; 'textarea',
                'label' =&gt; 'Message',
            ),
        ),
        array(
            'type' =&gt; 'Zend\Form\Element\Captcha',
            'name' =&gt; 'captcha',
            'attributes' =&gt; array(
                'label' =&gt; 'Please verify you are human',
                'captcha =&gt; array(
                    'class' =&gt; 'Dumb',
                ),
            ),
        ),
        array(
            'type' =&gt; 'Zend\Form\Element\Csrf',
            'name' =&gt; 'security',
        ),
        array(
            'name' =&gt; 'send',
            'attributes' =&gt; array(
                'type'  =&gt; 'submit',
                'label' =&gt; 'Send',
            ),
        ),
    ),
    /* If we had fieldsets, they'd go here; fieldsets contain
     * "elements" and "fieldsets" keys, and potentially a "type"
     * key indicating the specific FieldsetInterface 
     * implementation to use.
    'fieldsets' =&gt; array(
    ),
     */

    // Configuration to pass on to 
    // Zend\InputFilter\Factory::createInputFilter()
    'input_filter' =&gt; array(
        /* ... */
    ),
));
</pre>
<p>
            If we wanted to use fieldsets, as we demonstrated in the previous example, we could do
            the following:
        </p>
<pre class="programlisting">
use Zend\Form\Factory;
$factory = new Factory();
$form    = $factory-&gt;createForm(array(
    'hydrator'  =&gt; 'Zend\Stdlib\Hydrator\ArraySerializable'
    'fieldsets' =&gt; array(
        array(
            'name' =&gt; 'sender',
            'elements' =&gt; array(
                array(
                    'name' =&gt; 'name',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'text',
                        'label' =&gt; 'Your name',
                    ),
                ),
                array(
                    'name' =&gt; 'email',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'email',
                        'label' =&gt; 'Your email address',
                    ),
                ),
            ),
        ),
        array(
            'name' =&gt; 'details',
            'elements' =&gt; array(
                array(
                    'name' =&gt; 'subject',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'text',
                        'label' =&gt; 'Subject',
                    ),
                ),
                array(
                    'name' =&gt; 'message',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'textarea',
                        'label' =&gt; 'Message',
                    ),
                ),
            ),
        ),
    ),
    'elements' =&gt; array(
        array(
            'type' =&gt; 'Zend\Form\Element\Captcha',
            'name' =&gt; 'captcha',
            'attributes' =&gt; array(
                'label' =&gt; 'Please verify you are human',
                'captcha =&gt; array(
                    'class' =&gt; 'Dumb',
                ),
            ),
        ),
        array(
            'type' =&gt; 'Zend\Form\Element\Csrf',
            'name' =&gt; 'security',
        ),
        array(
            'name' =&gt; 'send',
            'attributes' =&gt; array(
                'type'  =&gt; 'submit',
                'label' =&gt; 'Send',
            ),
        ),
    ),

    // Configuration to pass on to 
    // Zend\InputFilter\Factory::createInputFilter()
    'input_filter' =&gt; array(
        /* ... */
    ),
));
</pre>
<p>
            Note that the chief difference is nesting; otherwise, the information is basically the
            same.
        </p>
<p>
            The chief benefits to using the <code class="classname">Factory</code> are allowing you to store
            definitions in configuration, and usage of significant whitespace.
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.extension"></a><p class="title"><b>Example 9.3. Factory-backed Form Extension</b></p>
<div class="example-contents">
<p>
            The default <code class="classname">Form</code> implementation is backed by the
            <code class="classname">Factory</code>. This allows you to extend it, and define your form
            internally. This has the benefit of allowing a mixture of programmatic and
            factory-backed creation, as well as defining a form for re-use in your application.
        </p>
<pre class="programlisting">
namespace Contact;

use Zend\Captcha\AdapterInterface as CaptchaAdapter;
use Zend\Form\Element;
use Zend\Form\Form;

class ContactForm extends Form
{
    protected $captcha;

    public function setCaptcha(CaptchaAdapter $captcha)
    {
        $this-&gt;captcha = $captcha;
    }

    public function prepareElements()
    {
        // add() can take either an Element/Fieldset instance, 
        // or a specification, from which the appropriate object
        // will be built.

        $this-&gt;add(array(
            'name' =&gt; 'name',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Your name',
            ),
        ));
        $this-&gt;add(array(
            'name' =&gt; 'email',
            'attributes' =&gt; array(
                'type'  =&gt; 'email',
                'label' =&gt; 'Your email address',
            ),
        ));
        $this-&gt;add(array(
            'name' =&gt; 'subject',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Subject',
            ),
        ));
        $this-&gt;add(array(
            'name' =&gt; 'message',
            'attributes' =&gt; array(
                'type'  =&gt; 'textarea',
                'label' =&gt; 'Message',
            ),
        ));
        $this-&gt;add(array(
            'type' =&gt; 'Zend\Form\Element\Captcha',
            'name' =&gt; 'captcha',
            'attributes' =&gt; array(
                'label' =&gt; 'Please verify you are human',
                'captcha =&gt; $this-&gt;captcha,
            ),
        )),
        $this-&gt;add(new Element\Csrf('security'));
        $this-&gt;add(array(
            'name' =&gt; 'send',
            'attributes' =&gt; array(
                'type'  =&gt; 'submit',
                'label' =&gt; 'Send',
            ),
        ));

        // We could also define the input filter here, or
        // lazy-create it in the getInputFilter() method.
    }
));
</pre>
<p>
            You'll note that this example introduces a method,
            <code class="methodname">prepareElements()</code>. This is done to allow altering and/or
            configuring either the form or input filter factory instances, which could then have
            bearing on how elements, inputs, etc. are created. In this case, it also allows
            injection of the CAPTCHA adapter, allowing us to configure it elsewhere in our
            application and inject it into the form.
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.validation"></a><p class="title"><b>Example 9.4. Validating Forms</b></p>
<div class="example-contents">
<p>
            Validating forms requires three steps. First, the form must have an input filter
            attached. Second, you must inject the data to validate into the form. Third, you
            validate the form. If invalid, you can retrieve the error messages, if any.
        </p>
<pre class="programlisting">
$form = new Contact\ContactForm();

// If the form doesn't define an input filter by default, inject one.
$form-&gt;setInputFilter(new Contact\ContactFilter());

// Get the data. In an MVC application, you might try:
$data = $request-&gt;post();  // for POST data
$data = $request-&gt;query(); // for GET (or query string) data

$form-&gt;setData($data);

// Validate the form
if ($form-&gt;isValid() {
    $validatedData = $form-&gt;getData();
} else {
    $messages = $form-&gt;getMessages();
}
</pre>
<p>
            You can get the raw data if you want, by accessing the composed input filter.
        </p>
<pre class="programlisting">
$filter = $form-&gt;getInputFilter();

$rawValues    = $filter-&gt;getRawValues();
$nameRawValue = $filter-&gt;getRawValue('name');
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.input-specification"></a><p class="title"><b>Example 9.5. Hinting to the Input Filter</b></p>
<div class="example-contents">
<p>
            Often, you'll create elements that you expect to behave in the same way on each usage,
            and for which you'll want specific filters or validation as well. Since the input filter
            is a separate object, how can you achieve these latter points?
        </p>
<p>
            Because the default form implementation composes a factory, and the default factory
            composes an input filter factory, you can have your elements and/or fieldsets hint to
            the input filter. If no input or input filter is provided in the input filter for that
            element, these hints will be retrieved and used to create them.
        </p>
<p>
            To do so, one of the following must occur. For elements, they must implement
            <code class="classname">Zend\InputFilter\InputProviderInterface</code>, which defines a
            <code class="methodname">getInputSpecification()</code> method; for fieldsets, they must
            implement <code class="classname">Zend\InputFilter\InputFilterProviderInterface</code>, which
            defines a <code class="methodname">getInputFilterSpecification()</code> method.
        </p>
<p>
            In the case of an element, the <code class="methodname">getInputSpecification()</code> method
            should return data to be used by the input filter factory to create an input.
        </p>
<pre class="programlisting">
namespace Contact\Form;

use Zend\Form\Element;
use Zend\InputFilter\InputProviderInterface;
use Zend\Validator;

class EmailElement extends Element implements InputProviderInterface
{
    protected $attributes = array(
        'type' =&gt; 'email',
    );

    public function getInputSpecification()
    {
        return array(
            'name'     =&gt; $this-&gt;getName(),
            'required' =&gt; true,
            'filters'  =&gt; array(
                array('name' =&gt; 'Zend\Filter\StringTrim'),
            ),
            'validators' =&gt; array(
                new Validator\Email(),
            ),
        );
    }
}
</pre>
<p>
            The above would hint to the input filter to create and attach an input named after the
            element, marking it as required, and giving it a <code class="classname">StringTrim</code>
            filter and an <code class="classname">Email</code> validator. Note that you can either rely on
            the input filter to create filters and validators, or directly instantiate them.
        </p>
<p>
            For fieldsets, you do very similarly; the difference is that
            <code class="methodname">getInputFilterSpecification()</code> must return configuration for an
            input filter.
        </p>
<pre class="programlisting">
namespace Contact\Form;

use Zend\Form\Fieldset;
use Zend\InputFilter\InputFilterProviderInterface;

class SenderFieldset extends Fieldset implements InputFilterProviderInterface
{
    public function getInputFilterSpecification()
    {
        return array(
            'name' =&gt; array(
                'required' =&gt; true,
                'filters'  =&gt; array(
                    array('name' =&gt; 'Zend\Filter\StringTrim'),
                ),
            ),
            'email' =&gt; array(
                'required' =&gt; true,
                'filters'  =&gt; array(
                    array('name' =&gt; 'Zend\Filter\StringTrim'),
                ),
                'validators' =&gt; array(
                    new Validator\Email(),
                ),
            ),
        );
    }
}
</pre>
<p>
            Specifications are a great way to make forms, fieldsets, and elements re-usable
            trivially in your applications. In fact, the <code class="classname">Captcha</code> and
            <code class="classname">Csrf</code> elements define specifications in order to ensure they can
            work without additional user configuration!
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.binding"></a><p class="title"><b>Example 9.6. Binding an object</b></p>
<div class="example-contents">
<p>
            As noted in the intro, forms in Zend Framework bridge the domain model and the view
            layer. Let's see that in action.
        </p>
<p>
            When you <code class="methodname">bind()</code> an object to the form, the following happens:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    The composed <code class="classname">Hydrator</code> calls
                    <code class="methodname">extract()</code> on the object, and uses the values returned,
                    if any, to populate the <code class="varname">value</code> attributes of all elements.
                </p></li>
<li class="listitem"><p>
                    When <code class="methodname">isValid()</code> is called, if
                    <code class="methodname">setData()</code> has not been previously set, the form uses
                    the composed <code class="classname">Hydrator</code> to extract values from the object,
                    and uses those during validation.
                </p></li>
<li class="listitem"><p>
                    If <code class="methodname">isValid()</code> is successful (and the
                    <code class="varname">bindOnValidate</code> flag is enabled, which is true by default),
                    then the <code class="classname">Hydrator</code> will be passed the validated values to
                    use to hydrate the bound object. (If you do not want this behavior, call
                    <code class="methodname">setBindOnValidate(FormInterface::BIND_MANUAL)</code>).
                </p></li>
<li class="listitem"><p>
                    If the object implements
                    <code class="classname">Zend\InputFilter\InputFilterAwareInterface</code>, the input
                    filter it composes will be used instead of the one composed on the form.
                </p></li>
</ul></div>
<p>
            This is easier to understand in practice.
        </p>
<pre class="programlisting">
$contact = new ArrayObject;
$contact['subject'] = '[Contact Form] ';
$contact['message'] = 'Type your message here';

$form    = new Contact\ContactForm;

$form-&gt;bind($contact); // form now has default values for 
                       // 'subject' and 'message'

$data = array(
    'name'    =&gt; 'John Doe',
    'email'   =&gt; 'j.doe@example.tld',
    'subject' =&gt; '[Contact Form] \'sup?',
);
$form-&gt;setData($data);

if ($form-&gt;isValid()) {
    // $contact now looks like:
    // array(
    //     'name'    =&gt; 'John Doe',
    //     'email'   =&gt; 'j.doe@example.tld',
    //     'subject' =&gt; '[Contact Form] \'sup?',
    //     'message' =&gt; 'Type your message here',
    // )
    // only as an ArrayObject
}
</pre>
<p>
            When an object is bound to the form, calling <code class="methodname">getData()</code> will
            return that object by default. If you want to return an associative array instead, you
            can pass the <code class="varname">FormInterface::VALUES_AS_ARRAY</code> flag to the method.
        </p>
<pre class="programlisting">
use Zend\Form\FormInterface;
$data = $form-&gt;getData(FormInterface::VALUES_AS_ARRAY);
</pre>
<p>
            Zend Framework ships several standard <a class="link" href="zend.stdlib.html#zend.stdlib.hydrator" title="18.1. Zend\Stdlib\Hydrator">hydrators</a>, and implementation is as simple as
            implementing <code class="classname">Zend\Stdlib\Hydrator\HydratorInterface</code>, which looks
            like this:
        </p>
<pre class="programlisting">
namespace Zend\Stdlib\Hydrator;

interface Hydrator
{
    /** @return array */
    public function extract($object);
    public function hydrate(array $data, $object);
}
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.rendering"></a><p class="title"><b>Example 9.7. Rendering</b></p>
<div class="example-contents">
<p>
            As noted previously, forms are meant to bridge the domain model and view layer. We've
            discussed the domain model binding, but what about the view?
        </p>
<p>
            The form component ships a set of form-specific view helpers. These accept the various
            form objects, and introspect them in order to generate markup. Typically, they will
            inspect the attributes, but in special cases, they may look at other properties and
            composed objects.
        </p>
<p>
            When preparing to render, you will likely want to call
            <code class="methodname">prepare()</code>. This method ensures that certain injections are
            done, and will likely in the future munge names to allow for
            <code class="varname">scoped[array][notation]</code>.
        </p>
<p>
            The most used and simplest view helpers available are
            <code class="classname">Form</code>, <code class="classname">FormElement</code>,
            <code class="classname">FormLabel</code>, and <code class="classname">FormElementErrors</code>. Let's
            use them to display the contact form.
        </p>
<pre class="programlisting">
&lt;?php
// within a view script
$form = $this-&gt;form;
$form-&gt;prepare();

// Assuming the "contact/process" route exists...
$form-&gt;setAttribute('action', $this-&gt;url('contact/process'));

// Set the method attribute for the form
$form-&gt;setAttribute('method', 'post');
 
// Render the opening tag
echo $this-&gt;form()-&gt;openTag($form);
?&gt;
&lt;div class="form_element"&gt;
&lt;?php 
    $name = $form-&gt;get('name');
    echo $this-&gt;formLabel()-&gt;openTag($name);
    echo $this-&gt;formInput($name);
    echo $this-&gt;formElementErrors($name);
    echo $this-&gt;formLabel()-&gt;closeTag();
?&gt;&lt;/div&gt;
 
&lt;div class="form_element"&gt;
&lt;?php 
    $subject = $form-&gt;get('subject');
    echo $this-&gt;formLabel()-&gt;openTag($subject);
    echo $this-&gt;formInput($subject);
    echo $this-&gt;formElementErrors($subject);
    echo $this-&gt;formLabel()-&gt;closeTag();
?&gt;&lt;/div&gt;
 
&lt;div class="form_element"&gt;
&lt;?php 
    $message = $form-&gt;get('message');
    echo $this-&gt;formLabel()-&gt;openTag($message);
    echo $this-&gt;formInput($message);
    echo $this-&gt;formElementErrors($message);
    echo $this-&gt;formLabel()-&gt;closeTag();
?&gt;&lt;/div&gt;
 
&lt;div class="form_element"&gt;
&lt;?php 
    $captcha = $form-&gt;get('captcha');
    echo $this-&gt;formLabel()-&gt;openTag($captcha);
    echo $this-&gt;formInput($captcha);
    echo $this-&gt;formElementErrors($captcha);
    echo $this-&gt;formLabel()-&gt;closeTag();
?&gt;&lt;/div&gt;

&lt;?php echo $this-&gt;formElement($form-&gt;get('security') ?&gt;
&lt;?php echo $this-&gt;formElement($form-&gt;get('send') ?&gt;
 
&lt;?php echo $this-&gt;form()-&gt;closeTag() ?&gt;
</pre>
<p>
            There are a few things to note about this. First, to prevent confusion in IDEs and
            editors when syntax highlighting, we use helpers to both open and close the form and
            label tags. Second, there's a lot of repetition happening here; we could easily create a
            partial view script or a composite helper to reduce boilerplate. Third, note that not
            all elements are created equal -- the CSRF and submit elements don't need labels or
            error messages necessarily. Finally, note that the <code class="classname">FormElement</code>
            helper tries to do the right thing -- it delegates actual markup generation toother view
            helpers; however, it can only guess what specific form helper to delegate to based on
            the list it has. If you introduce new form view helpers, you'll need to extend the
            <code class="classname">FormElement</code> helper, or create your own.
        </p>
<p>
            Currently, the complete list of available form helpers is:
            <code class="classname">FormCaptcha</code>, 
            <code class="classname">FormInput</code> (which handles any type that the input HTML element
            accepts), <code class="classname">FormMultiCheckbox</code> (for creating sets of related
            checkboxes), <code class="classname">FormRadio</code>, <code class="classname">FormSelect</code>
            (which can also handle optgroups), and <code class="classname">FormTextarea</code>.
        </p>
<p>
            In order to use these form view helpers in the first place, you need to inform the
            helper loader about them. The easiest way to do this is in your configuration; simply
            add an entry for <code class="classname">Zend\Form\View\HelperLoader</code> to the
            <code class="varname">helper_map</code> key of the <code class="varname">view_manager</code> configuration:
        </p>
<pre class="programlisting">
// In some module configuration, or a config/autoload/ configuration file:
return array(
    'view_manager' =&gt; array(
        'helper_map' =&gt; array(
            'Zend\Form\View\HelperLoader,
        ),
    ),
);
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.partial"></a><p class="title"><b>Example 9.8. Validation Groups</b></p>
<div class="example-contents">
<p>
            Sometimes you want to validate only a subset of form elements. As an example, let's say
            we're re-using our contact form over a web service; in this case, the
            <code class="classname">Csrf</code>, <code class="classname">Captcha</code>, and submit button elements
            are not of interest, and shouldn't be validated.
        </p>
<p>
            <code class="classname">Zend\Form</code> provides a proxy method to the underlying
            <code class="classname">InputFilter</code>'s <code class="methodname">setValidationGroup()</code>
            method, allowing us to perform this operation.
        </p>
<pre class="programlisting">
$form-&gt;setValidationGroup('name', 'email', 'subject', 'message');
$form-&gt;setData($data);
if ($form-&gt;isValid()) {
    // Contains only the "name", "email", "subject", and "message" values
    $data = $form-&gt;getData();
}
</pre>
<p>
            If you later want to reset the form to validate all, simply pass the
            <code class="varname">FormInterface::VALIDATE_ALL</code> flag to the
            <code class="methodname">setValidationGroup()</code> method.
        </p>
<pre class="programlisting">
use Zend\Form\FormInterface;
$form-&gt;setValidationGroup(FormInterface::VALIDATE_ALL);
</pre>
</div>
</div>
<br class="example-break">
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.form.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.form.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.http.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 9. Zend_Form </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 10. Zend_Http</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
