<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>28.3. Zend\XmlRpc\Server</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.xmlrpc.html" title="Chapter 28. Zend_XmlRpc">
<link rel="prev" href="zend.xmlrpc.client.html" title="28.2. Zend\XmlRpc\Client">
<link rel="next" href="copyrights.html" title="Appendix A. Copyright Information">
<link rel="part" href="introduction.html" title="Part I. Introduction to Zend Framework">
<link rel="chapter" href="introduction.overview.html" title="Chapter 1. Overview">
<link rel="chapter" href="introduction.installation.html" title="Chapter 2. Installation">
<link rel="part" href="learning.html" title="Part II. Learning Zend Framework">
<link rel="article" href="learning.di.html" title="Learning Dependency Injection">
<link rel="part" href="reference.html" title="Part III. Zend Framework Reference">
<link rel="chapter" href="zend.acl.html" title="Chapter 3. Zend\Acl">
<link rel="chapter" href="zend.authentication.html" title="Chapter 4. Zend\Authentication">
<link rel="chapter" href="zend.barcode.html" title="Chapter 5. Zend\Barcode">
<link rel="chapter" href="zend.cache.html" title="Chapter 6. Zend\Cache">
<link rel="chapter" href="zend.captcha.html" title="Chapter 7. Zend\Captcha">
<link rel="chapter" href="zend.config.html" title="Chapter 8. Zend_Config">
<link rel="chapter" href="zend.crypt.html" title="Chapter 9. Zend_Crypt">
<link rel="chapter" href="zend.db.html" title="Chapter 10. Zend_Db">
<link rel="chapter" href="zend.di.html" title="Chapter 11. Zend\Di">
<link rel="chapter" href="zend.dom.html" title="Chapter 12. Zend\Dom">
<link rel="chapter" href="zend.event-manager.html" title="Chapter 13. Zend\EventManager">
<link rel="chapter" href="zend.form.html" title="Chapter 14. Zend_Form">
<link rel="chapter" href="zend.http.html" title="Chapter 15. Zend_Http">
<link rel="chapter" href="zend.i18n.html" title="Chapter 16. Zend_I18n">
<link rel="chapter" href="zend.input-filter.html" title="Chapter 17. Zend\InputFilter">
<link rel="chapter" href="zend.ldap.html" title="Chapter 18. Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="Chapter 19. Zend\Loader">
<link rel="refentry" href="zend.loader.autoloader-factory.methods.factory.html" title="factory">
<link rel="refentry" href="zend.loader.autoloader-factory.methods.get-registered-autoloaders.html" title="getRegisteredAutoloaders">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.add-static-map.html" title="addStaticMap">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.register-plugin.html" title="registerPlugin">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.register-plugins.html" title="registerPlugins">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.unregister-plugin.html" title="unregisterPlugin">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.get-registered-plugins.html" title="getRegisteredPlugins">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.is-loaded.html" title="isLoaded">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.get-class-name.html" title="getClassName">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.load.html" title="load">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.get-iterator.html" title="getIterator">
<link rel="refentry" href="zend.loader.short-name-locator.methods.is-loaded.html" title="isLoaded">
<link rel="refentry" href="zend.loader.short-name-locator.methods.get-class-name.html" title="getClassName">
<link rel="refentry" href="zend.loader.short-name-locator.methods.load.html" title="load">
<link rel="refentry" href="zend.loader.plugin-class-locator.methods.register-plugin.html" title="registerPlugin">
<link rel="refentry" href="zend.loader.plugin-class-locator.methods.unregister-plugin.html" title="unregisterPlugin">
<link rel="refentry" href="zend.loader.plugin-class-locator.methods.get-registered-plugins.html" title="getRegisteredPlugins">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.autoload.html" title="autoload">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.register.html" title="register">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.register-autoload-map.html" title="registerAutoloadMap">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.register-autoload-maps.html" title="registerAutoloadMaps">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.get-autoload-map.html" title="getAutoloadMap">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.autoload.html" title="autoload">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.register.html" title="register">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.set-fallback-autoloader.html" title="setFallbackAutoloader">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.is-fallback-autoloader.html" title="isFallbackAutoloader">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-namespace.html" title="registerNamespace">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-namespaces.html" title="registerNamespaces">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-prefix.html" title="registerPrefix">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-prefixes.html" title="registerPrefixes">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.autoload.html" title="autoload">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register.html" title="register">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.add-static-paths.html" title="addStaticPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.add-prefix-path.html" title="addPrefixPath">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.add-prefix-paths.html" title="addPrefixPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-paths.html" title="getPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.clear-paths.html" title="clearPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.remove-prefix-path.html" title="removePrefixPath">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.is-loaded.html" title="isLoaded">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-class-name.html" title="getClassName">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.load.html" title="load">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-plugin-map.html" title="getPluginMap">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-class-map.html" title="getClassMap">
<link rel="refentry" href="zend.loader.prefix-path-mapper.methods.add-prefix-path.html" title="addPrefixPath">
<link rel="refentry" href="zend.loader.prefix-path-mapper.methods.remove-prefix-path.html" title="removePrefixPath">
<link rel="chapter" href="zend.mail.html" title="Chapter 20. Zend\Mail">
<link rel="chapter" href="zend.module-manager.html" title="Chapter 21. Zend\ModuleManager">
<link rel="chapter" href="zend.mvc.html" title="Chapter 22. Zend\Mvc">
<link rel="chapter" href="zend.service-manager.html" title="Chapter 23. Zend\ServiceManager">
<link rel="chapter" href="zend.stdlib.html" title="Chapter 24. Zend\Stdlib">
<link rel="chapter" href="zend.uri.html" title="Chapter 25. Zend_Uri">
<link rel="chapter" href="zend.validator.html" title="Chapter 26. Zend\Validator">
<link rel="chapter" href="zend.view.html" title="Chapter 27. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapter 28. Zend_XmlRpc">
<link rel="appendix" href="copyrights.html" title="Appendix A. Copyright Information">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.introduction" title="28.3.1. Introduction">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.usage" title="28.3.2. Basic Usage">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.structure" title="28.3.3. Server Structure">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.anatomy" title="28.3.4. Anatomy of a webservice">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.conventions" title="28.3.5. Conventions">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.namespaces" title="28.3.6. Utilizing Namespaces">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.request" title="28.3.7. Custom Request Objects">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.response" title="28.3.8. Custom Responses">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.fault" title="28.3.9. Handling Exceptions via Faults">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.caching" title="28.3.10. Caching Server Definitions Between Requests">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.use" title="28.3.11. Usage Examples">
<link rel="subsection" href="zend.xmlrpc.server.html#zend.xmlrpc.server.performance" title="28.3.12. Performance optimization">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">28.3. Zend\XmlRpc\Server</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.xmlrpc.client.html">Prev</a> </td>
<th width="60%" align="center">Chapter 28. Zend_XmlRpc</th>
<td width="20%" align="right"> <a accesskey="n" href="copyrights.html">Next</a>
</td>
</tr>
</table></div>
<div class="section" title="28.3. Zend\XmlRpc\Server">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.xmlrpc.server"></a>28.3. Zend\XmlRpc\Server</h2></div></div></div>
<div class="section" title="28.3.1. Introduction">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.introduction"></a>28.3.1. Introduction</h3></div></div></div>
<p>
            <code class="classname">Zend\XmlRpc\Server</code> is intended as a fully-featured
            <acronym class="acronym">XML-RPC</acronym> server, following <a class="link" href="http://www.xmlrpc.com/spec" target="_top">the
                specifications outlined at www.xmlrpc.com</a>. Additionally, it implements the
            <span class="command"><strong>system.multicall()</strong></span> method, allowing boxcarring of requests.
        </p>
</div>
<div class="section" title="28.3.2. Basic Usage">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.usage"></a>28.3.2. Basic Usage</h3></div></div></div>
<p>
            An example of the most basic use case:
        </p>
<pre class="programlisting">
$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('My\Service\Class');
echo $server-&gt;handle();
</pre>
</div>
<div class="section" title="28.3.3. Server Structure">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.structure"></a>28.3.3. Server Structure</h3></div></div></div>
<p>
            <code class="classname">Zend\XmlRpc\Server</code> is composed of a variety of components,
            ranging from the server itself to request, response, and fault objects.
        </p>
<p>
            To bootstrap <code class="classname">Zend\XmlRpc\Server</code>, the developer must attach one or
            more classes or functions to the server, via the
            <code class="methodname">setClass()</code> and <code class="methodname">addFunction()</code> methods.
        </p>
<p>
            Once done, you may either pass a <code class="classname">Zend\XmlRpc\Request</code>
            object to <code class="methodname">Zend\XmlRpc\Server::handle()</code>, or it will
            instantiate a <code class="classname">Zend\XmlRpc\Request\Http</code> object if none
            is provided -- thus grabbing the request from
            <code class="filename">php://input</code>.
        </p>
<p>
            <code class="methodname">Zend\XmlRpc\Server::handle()</code> then attempts to
            dispatch to the appropriate handler based on the method
            requested. It then returns either a
            <code class="classname">Zend\XmlRpc\Response</code>-based object or a
            <code class="classname">Zend\XmlRpc\Server\Fault</code>object. These objects both have
            <code class="methodname">__toString()</code> methods that create valid
            <acronym class="acronym">XML-RPC</acronym> <acronym class="acronym">XML</acronym> responses, allowing them to be
            directly echoed.
        </p>
</div>
<div class="section" title="28.3.4. Anatomy of a webservice">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.anatomy"></a>28.3.4. Anatomy of a webservice</h3></div></div></div>
<div class="section" title="28.3.4.1. General considerations">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.anatomy.general"></a>28.3.4.1. General considerations</h4></div></div></div>
<p>
                For maximum performance it is recommended to use a simple
                bootstrap file for the server component. Using
                <code class="classname">Zend\XmlRpc\Server</code> inside a
                <a class="link" href=""><code class="classname">Zend\Controller</code></a>
                is strongly discouraged to avoid the overhead.
            </p>
<p>
                Services change over time and while webservices are generally
                less change intense as code-native <acronym class="acronym">APIs</acronym>, it
                is recommended to version your service. Do so to lay grounds to
                provide compatibility for clients using older versions of your
                service and manage your service lifecycle including deprecation
                timeframes.To do so just include a version number into your
                <acronym class="acronym">URI</acronym>. It is also recommended to include the
                remote protocol name in the <acronym class="acronym">URI</acronym> to allow easy
                integration of upcoming remoting technologies.
                http://myservice.ws/<span class="emphasis"><em>1.0/XMLRPC/</em></span>.
            </p>
</div>
<div class="section" title="28.3.4.2. What to expose?">
<div class="titlepage"><div><div><h4 class="title">
<a name="zend.xmlrpc.server.anatomy.expose"></a>28.3.4.2. What to expose?</h4></div></div></div>
<p>
                Most of the time it is not sensible to expose business objects
                directly. Business objects are usually small and under heavy
                change, because change is cheap in this layer of your
                application. Once deployed and adopted, web services are hard to
                change. Another concern is <acronym class="acronym">I/O</acronym> and latency:
                the best webservice calls are those not happening. Therefore
                service calls need to be more coarse-grained than usual business
                logic is. Often an additional layer in front of your business
                objects makes sense. This layer is sometimes referred to as <a class="link" href="http://martinfowler.com/eaaCatalog/remoteFacade.html" target="_top">Remote
                    Facade</a>.
                Such a service layer adds a coarse grained interface on top of
                your business logic and groups verbose operations into smaller
                ones.
            </p>
</div>
</div>
<div class="section" title="28.3.5. Conventions">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.conventions"></a>28.3.5. Conventions</h3></div></div></div>
<p>
            <code class="classname">Zend\XmlRpc\Server</code> allows the developer to attach functions and
            class method calls as dispatchable <acronym class="acronym">XML-RPC</acronym> methods. Via
            <code class="classname">Zend\Server\Reflection</code>, it does introspection on all attached
            methods, using the function and method docblocks to determine the
            method help text and method signatures.
        </p>
<p>
            <acronym class="acronym">XML-RPC</acronym> types do not necessarily map one-to-one to
            <acronym class="acronym">PHP</acronym> types. However, the code will do its best to guess the
            appropriate type based on the values listed in @param and @return lines. Some
            <acronym class="acronym">XML-RPC</acronym> types have no immediate <acronym class="acronym">PHP</acronym> equivalent,
            however, and should be hinted using the <acronym class="acronym">XML-RPC</acronym> type in the PHPDoc.
            These include:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <span class="emphasis"><em><span class="property">dateTime.iso8601</span></em></span>, a string formatted
                    as '<span class="command"><strong>YYYYMMDDTHH:mm:ss</strong></span>'
                </p></li>
<li class="listitem"><p><span class="emphasis"><em>base64</em></span>, base64 encoded data</p></li>
<li class="listitem"><p><span class="emphasis"><em>struct</em></span>, any associative array</p></li>
</ul></div>
<p>
            An example of how to hint follows:
        </p>
<pre class="programlisting">
/**
* This is a sample function
*
* @param base64 $val1 Base64-encoded data
* @param dateTime.iso8601 $val2 An ISO date
* @param struct $val3 An associative array
* @return struct
*/
function myFunc($val1, $val2, $val3)
{
}
</pre>
<p>
            PhpDocumentor does no validation of the types specified for params
            or return values, so this will have no impact on your <acronym class="acronym">API</acronym>
            documentation. Providing the hinting is necessary, however, when the
            server is validating the parameters provided to the method call.
        </p>
<p>
            It is perfectly valid to specify multiple types for both params and
            return values; the <acronym class="acronym">XML-RPC</acronym> specification even suggests that
            system.methodSignature should return an array of all possible method
            signatures (i.e., all possible combinations of param and return
            values). You may do so just as you normally would with
            PhpDocumentor, using the '|' operator:
        </p>
<pre class="programlisting">
/**
* This is a sample function
*
* @param string|base64 $val1 String or base64-encoded data
* @param string|dateTime.iso8601 $val2 String or an ISO date
* @param array|struct $val3 Normal indexed array or an associative array
* @return boolean|struct
*/
function myFunc($val1, $val2, $val3)
{
}
</pre>
<div class="note" title="Note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                Allowing multiple signatures can lead to confusion for developers
                using the services; to keep things simple, a <acronym class="acronym">XML-RPC</acronym>
                service method should only have a single signature.
            </p></td></tr>
</table></div>
</div>
<div class="section" title="28.3.6. Utilizing Namespaces">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.namespaces"></a>28.3.6. Utilizing Namespaces</h3></div></div></div>
<p>
            <acronym class="acronym">XML-RPC</acronym> has a concept of namespacing; basically, it allows grouping
            <acronym class="acronym">XML-RPC</acronym> methods by dot-delimited namespaces. This helps prevent
            naming collisions between methods served by different classes. As an
            example, the <acronym class="acronym">XML-RPC</acronym> server is expected to server several methods in
            the 'system' namespace:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>system.listMethods</p></li>
<li class="listitem"><p>system.methodHelp</p></li>
<li class="listitem"><p>system.methodSignature</p></li>
</ul></div>
<p>
            Internally, these map to the methods of the same name in
            <code class="classname">Zend\XmlRpc\Server</code>.
        </p>
<p>
            If you want to add namespaces to the methods you serve, simply
            provide a namespace to the appropriate method when attaching a
            function or class:
        </p>
<pre class="programlisting">
// All public methods in My_Service_Class will be accessible as
// myservice.METHODNAME
$server-&gt;setClass('My\Service\Class', 'myservice');

// Function 'somefunc' will be accessible as funcs.somefunc
$server-&gt;addFunction('somefunc', 'funcs');
</pre>
</div>
<div class="section" title="28.3.7. Custom Request Objects">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.request"></a>28.3.7. Custom Request Objects</h3></div></div></div>
<p>
            Most of the time, you'll simply use the default request type included with
            <code class="classname">Zend\XmlRpc\Server</code>,
            <code class="classname">Zend\XmlRpc\Request\Http</code>. However, there may be times when you
            need <acronym class="acronym">XML-RPC</acronym> to be available via the <acronym class="acronym">CLI</acronym>, a
            <acronym class="acronym">GUI</acronym>, or other environment, or want to log incoming requests. To do
            so, you may create a custom request object that extends
            <code class="classname">Zend\XmlRpc\Request</code>. The most important thing to remember is to
            ensure that the <code class="methodname">getMethod()</code> and
            <code class="methodname">getParams()</code> methods are implemented so that the
            <acronym class="acronym">XML-RPC</acronym> server can retrieve that information in order to dispatch the
            request.
        </p>
</div>
<div class="section" title="28.3.8. Custom Responses">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.response"></a>28.3.8. Custom Responses</h3></div></div></div>
<p>
            Similar to request objects, <code class="classname">Zend\XmlRpc\Server</code> can return custom
            response objects; by default, a <code class="classname">Zend_XmlRpc_Response_Http</code> object
            is returned, which sends an appropriate Content-Type <acronym class="acronym">HTTP</acronym> header for
            use with <acronym class="acronym">XML-RPC</acronym>. Possible uses of a custom object would be to log
            responses, or to send responses back to <code class="constant">STDOUT</code>.
        </p>
<p>
            To use a custom response class, use
            <code class="methodname">Zend\XmlRpc\Server::setResponseClass()</code> prior to calling
            <code class="methodname">handle()</code>.
        </p>
</div>
<div class="section" title="28.3.9. Handling Exceptions via Faults">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.fault"></a>28.3.9. Handling Exceptions via Faults</h3></div></div></div>
<p>
            <code class="classname">Zend_XmlRpc_Server</code> catches Exceptions generated by a dispatched
            method, and generates an <acronym class="acronym">XML-RPC</acronym> fault response when such an
            exception is caught. By default, however, the exception messages and
            codes are not used in a fault response. This is an intentional
            decision to protect your code; many exceptions expose more
            information about the code or environment than a developer would
            necessarily intend (a prime example includes database abstraction or
            access layer exceptions).
        </p>
<p>
            Exception classes can be whitelisted to be used as fault responses,
            however. To do so, simply utilize
            <code class="methodname">Zend\XmlRpc\Server\Fault::attachFaultException()</code> to pass an
            exception class to whitelist:
        </p>
<pre class="programlisting">
Zend\XmlRpc\Server\Fault::attachFaultException('My\Project\Exception');
</pre>
<p>
            If you utilize an exception class that your other project exceptions
            inherit, you can then whitelist a whole family of exceptions at a
            time. <code class="classname">Zend\XmlRpc\Server\Exception</code>s are always whitelisted, to
            allow reporting specific internal errors (undefined methods, etc.).
        </p>
<p>
            Any exception not specifically whitelisted will generate a fault
            response with a code of '404' and a message of 'Unknown error'.
        </p>
</div>
<div class="section" title="28.3.10. Caching Server Definitions Between Requests">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.caching"></a>28.3.10. Caching Server Definitions Between Requests</h3></div></div></div>
<p>
            Attaching many classes to an <acronym class="acronym">XML-RPC</acronym> server instance can utilize a
            lot of resources; each class must introspect using the Reflection
            <acronym class="acronym">API</acronym> (via <code class="classname">Zend_Server_Reflection</code>), which in
            turn generates a list of all possible method signatures to provide to the server class.
        </p>
<p>
            To reduce this performance hit somewhat, <code class="classname">Zend\XmlRpc\Server\Cache</code>
            can be used to cache the server definition between requests. When
            combined with <code class="methodname">__autoload()</code>, this can greatly increase
            performance.
        </p>
<p>
            An sample usage follows:
        </p>
<pre class="programlisting">
use Zend\XmlRpc\Server as XmlRpcServer;

// Register the "My\Services" namespace
$loader = new Zend\Loader\StandardAutoloader();
$loader-&gt;registerNamespace('My\Services', 'path to My/Services');
$loader-&gt;register();

$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';
$server = new XmlRpcServer();

if (!XmlRpcServer\Cache::get($cacheFile, $server)) {

    $server-&gt;setClass('My\Services\Glue', 'glue');   // glue. namespace
    $server-&gt;setClass('My\Services\Paste', 'paste'); // paste. namespace
    $server-&gt;setClass('My\Services\Tape', 'tape');   // tape. namespace

    XmlRpcServer\Cache::save($cacheFile, $server);
}

echo $server-&gt;handle();
</pre>
<p>
            The above example attempts to retrieve a server definition from
            <span class="property">xmlrpc.cache</span> in the same directory as the script. If unsuccessful,
            it loads the service classes it needs, attaches them to the server
            instance, and then attempts to create a new cache file with the
            server definition.
        </p>
</div>
<div class="section" title="28.3.11. Usage Examples">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.use"></a>28.3.11. Usage Examples</h3></div></div></div>
<p>
            Below are several usage examples, showing the full spectrum of
            options available to developers. Usage examples will each build
            on the previous example provided.
        </p>
<div class="example">
<a name="zend.xmlrpc.server.use.attach-function"></a><p class="title"><b>Example 28.8. Basic Usage</b></p>
<div class="example-contents">
<p>
                The example below attaches a function as a dispatchable <acronym class="acronym">XML-RPC</acronym>
                method and handles incoming calls.
            </p>
<pre class="programlisting">
/**
 * Return the MD5 sum of a value
 *
 * @param string $value Value to md5sum
 * @return string MD5 sum of value
 */
function md5Value($value)
{
    return md5($value);
}

$server = new Zend\XmlRpc\Server();
$server-&gt;addFunction('md5Value');
echo $server-&gt;handle();
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.attach-class"></a><p class="title"><b>Example 28.9. Attaching a class</b></p>
<div class="example-contents">
<p>
                The example below illustrates attaching a class' public methods
                as dispatchable <acronym class="acronym">XML-RPC</acronym> methods.
            </p>
<pre class="programlisting">
require_once 'Services/Comb.php';

$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('Services\Comb');
echo $server-&gt;handle();
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.attach-class-with-arguments"></a><p class="title"><b>Example 28.10. Attaching a class with arguments</b></p>
<div class="example-contents">
<p>
                The following example illustrates how to attach a class' public
                methods and passing arguments to its methods. This can be used to specify certain
                defaults when registering service classes.
            </p>
<pre class="programlisting">
class Services_PricingService
{
    /**
     * Calculate current price of product with $productId
     *
     * @param ProductRepository $productRepository
     * @param PurchaseRepository $purchaseRepository
     * @param integer $productId
     */
    public function calculate(ProductRepository $productRepository,
                              PurchaseRepository $purchaseRepository,
                              $productId)
    {
        ...
    }
}

$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('Services\PricingService',
                  'pricing',
                  new ProductRepository(),
                  new PurchaseRepository());
</pre>
<p>
                The arguments passed at <code class="methodname">setClass()</code> at server construction
                time are injected into the method call <span class="command"><strong>pricing.calculate()</strong></span> on
                remote invokation. In the example above, only the argument
                <code class="varname">$purchaseId</code> is expected from the client.
            </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.attach-class-with-arguments-constructor"></a><p class="title"><b>Example 28.11. Passing arguments only to constructor</b></p>
<div class="example-contents">
<p>
                <code class="classname">Zend\XmlRpc\Server</code> allows to restrict argument passing to
                constructors only. This can be used for constructor dependency injection.
                To limit injection to constructors, call
                <code class="methodname">sendArgumentsToAllMethods</code> and pass
                <code class="constant">FALSE</code> as an argument. This disables the default behavior of all
                arguments being injected into the remote method. In the example below the instance
                of <code class="classname">ProductRepository</code> and
                <code class="classname">PurchaseRepository</code> is only injected into the constructor of
                <code class="classname">Services_PricingService2</code>.
            </p>
<pre class="programlisting">
class Services\PricingService2
{
    /**
     * @param ProductRepository $productRepository
     * @param PurchaseRepository $purchaseRepository
     */
    public function __construct(ProductRepository $productRepository,
                                PurchaseRepository $purchaseRepository)
    {
        ...
    }

    /**
     * Calculate current price of product with $productId
     *
     * @param integer $productId
     * @return double
     */
    public function calculate($productId)
    {
        ...
    }
}

$server = new Zend\XmlRpc\Server();
$server-&gt;sendArgumentsToAllMethods(false);
$server-&gt;setClass('Services\PricingService2',
                  'pricing',
                  new ProductRepository(),
                  new PurchaseRepository());
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.attach-instance"></a><p class="title"><b>Example 28.12. Attaching a class instance</b></p>
<div class="example-contents"><p>
                <code class="methodname">setClass()</code> allows to register a previously instantiated
                object at the server. Just pass an instance instead of the class name. Obviously
                passing arguments to the constructor is not possible with pre-instantiated
                objects.
            </p></div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.attach-several-classes-namespaces"></a><p class="title"><b>Example 28.13. Attaching several classes using namespaces</b></p>
<div class="example-contents">
<p>
                The example below illustrates attaching several classes, each
                with their own namespace.
            </p>
<pre class="programlisting">
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('Services\Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services\Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services\Pick', 'pick');   // methods called as pick.*
echo $server-&gt;handle();
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.exceptions-faults"></a><p class="title"><b>Example 28.14. Specifying exceptions to use as valid fault responses</b></p>
<div class="example-contents">
<p>
                The example below allows any <code class="classname">Services\Exception</code>-derived
                class to report its code and message in the fault response.
            </p>
<pre class="programlisting">
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Allow Services_Exceptions to report as fault responses
Zend\XmlRpc\Server\Fault::attachFaultException('Services\Exception');

$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('Services\Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services\Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services\Pick', 'pick');   // methods called as pick.*
echo $server-&gt;handle();
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.custom-request-object"></a><p class="title"><b>Example 28.15. Utilizing custom request and response objects</b></p>
<div class="example-contents">
<p>
                Some use cases require to utilize a custom request object.
                For example, <acronym class="acronym">XML/RPC</acronym> is not bound to
                <acronym class="acronym">HTTP</acronym> as a transfer protocol. It is possible to use
                other transfer protocols like <acronym class="acronym">SSH</acronym> or telnet to send
                the request and response data over the wire. Another use case is
                authentication and authorization. In case of a different transfer
                protocol, one need to change the implementation to read request data.
            </p>
<p>
                The example below instantiates a custom request object and
                passes it to the server to handle.
            </p>
<pre class="programlisting">
require_once 'Services/Request.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Allow Services_Exceptions to report as fault responses
Zend\XmlRpc\Server\Fault::attachFaultException('Services\Exception');

$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('Services\Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services\Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services\Pick', 'pick');   // methods called as pick.*

// Create a request object
$request = new Services\Request();

echo $server-&gt;handle($request);
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.xmlrpc.server.use.custom-response-object"></a><p class="title"><b>Example 28.16. Specifying a custom response class</b></p>
<div class="example-contents">
<p>
                The example below illustrates specifying a custom response class
                for the returned response.
            </p>
<pre class="programlisting">
require_once 'Services/Request.php';
require_once 'Services/Response.php';
require_once 'Services/Exception.php';
require_once 'Services/Comb.php';
require_once 'Services/Brush.php';
require_once 'Services/Pick.php';

// Allow Services_Exceptions to report as fault responses
Zend\XmlRpc\Server\Fault::attachFaultException('Services\Exception');

$server = new Zend\XmlRpc\Server();
$server-&gt;setClass('Services\Comb', 'comb');   // methods called as comb.*
$server-&gt;setClass('Services\Brush', 'brush'); // methods called as brush.*
$server-&gt;setClass('Services\Pick', 'pick');   // methods called as pick.*

// Create a request object
$request = new Services\Request();

// Utilize a custom response
$server-&gt;setResponseClass('Services\Response');

echo $server-&gt;handle($request);
</pre>
</div>
</div>
<br class="example-break">
</div>
<div class="section" title="28.3.12. Performance optimization">
<div class="titlepage"><div><div><h3 class="title">
<a name="zend.xmlrpc.server.performance"></a>28.3.12. Performance optimization</h3></div></div></div>
<div class="example">
<a name="zend.xmlrpc.server.performance.caching"></a><p class="title"><b>Example 28.17. Cache server definitions between requests</b></p>
<div class="example-contents">
<p>
                The example below illustrates caching server definitions between requests.
            </p>
<pre class="programlisting">
use Zend\XmlRpc\Server as XmlRpcServer;

// Register the "Services" namespace
$loader = new Zend\Loader\StandardAutoloader();
$loader-&gt;registerNamespace('Services', 'path to Services');
$loader-&gt;register();

// Specify a cache file
$cacheFile = dirname(__FILE__) . '/xmlrpc.cache';

// Allow Services\Exceptions to report as fault responses
XmlRpcServer\Fault::attachFaultException('Services\Exception');

$server = new XmlRpcServer();

// Attempt to retrieve server definition from cache
if (!XmlRpcServer\Cache::get($cacheFile, $server)) {
    $server-&gt;setClass('Services\Comb', 'comb');   // methods called as comb.*
    $server-&gt;setClass('Services\Brush', 'brush'); // methods called as brush.*
    $server-&gt;setClass('Services\Pick', 'pick');   // methods called as pick.*

    // Save cache
    XmlRpcServer\Cache::save($cacheFile, $server);
}

// Create a request object
$request = new Services\Request();

// Utilize a custom response
$server-&gt;setResponseClass('Services\Response');

echo $server-&gt;handle($request);
</pre>
</div>
</div>
<br class="example-break"><div class="note" title="Note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
                The server cache file should be located outside the document root.
            </p></td></tr>
</table></div>
<div class="example">
<a name="zend.xmlrpc.server.performance.xmlgen"></a><p class="title"><b>Example 28.18. Optimizing XML generation</b></p>
<div class="example-contents">
<p>
                <code class="classname">Zend\XmlRpc\Server</code> uses
                <code class="classname">DOMDocument</code> of <acronym class="acronym">PHP</acronym>
                extension <span class="emphasis"><em>ext/dom</em></span> to generate it's
                <acronym class="acronym">XML</acronym> output. While <span class="emphasis"><em>ext/dom</em></span> is
                available on a lot of hosts it is not exactly the fastest.
                Benchmarks have shown, that <code class="classname">XmlWriter</code>
                from <span class="emphasis"><em>ext/xmlwriter</em></span> performs better.
            </p>
<p>
                If <span class="emphasis"><em>ext/xmlwriter</em></span> is available on your host, you can
                select a the <code class="classname">XmlWriter</code>-based generator
                to leaverage the performance differences.
            </p>
<pre class="programlisting">
use Zend\XmlRpc;

XmlRpc\Value::setGenerator(new XmlRpc\Generator\XmlWriter());

$server = new XmlRpc\Server();
...
</pre>
</div>
</div>
<br class="example-break"><div class="note" title="Benchmark your application"><table border="0" summary="Note: Benchmark your application">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Benchmark your application</th>
</tr>
<tr><td align="left" valign="top"><p>
                Performance is determined by a lot of parameters and
                benchmarks only apply for the specific test case. Differences
                come from <acronym class="acronym">PHP</acronym> version, installed extensions, webserver and
                operating system just to name a few. Please make sure to
                benchmark your application on your own and decide which
                generator to use based on <span class="emphasis"><em>your</em></span> numbers.
            </p></td></tr>
</table></div>
<div class="note" title="Benchmark your client"><table border="0" summary="Note: Benchmark your client">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">Benchmark your client</th>
</tr>
<tr><td align="left" valign="top"><p>
                This optimization makes sense for the client side too. Just
                select the alternate <acronym class="acronym">XML</acronym> generator before
                doing any work with <code class="classname">Zend\XmlRpc\Client</code>.
            </p></td></tr>
</table></div>
</div>
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.xmlrpc.client.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.xmlrpc.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="copyrights.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">28.2. Zend\XmlRpc\Client </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Appendix A. Copyright Information</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
