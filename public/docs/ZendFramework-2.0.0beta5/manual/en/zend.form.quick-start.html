<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>14.2. Zend\Form Quick Start</title>
<link rel="stylesheet" type="text/css" href="dbstyle.css">
<meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1">
<link rel="home" href="index.html" title="Programmer's Reference Guide">
<link rel="up" href="zend.form.html" title="Chapter 14. Zend_Form">
<link rel="prev" href="zend.form.html" title="Chapter 14. Zend_Form">
<link rel="next" href="zend.http.html" title="Chapter 15. Zend_Http">
<link rel="part" href="introduction.html" title="Part I. Introduction to Zend Framework">
<link rel="chapter" href="introduction.overview.html" title="Chapter 1. Overview">
<link rel="chapter" href="introduction.installation.html" title="Chapter 2. Installation">
<link rel="part" href="learning.html" title="Part II. Learning Zend Framework">
<link rel="article" href="learning.di.html" title="Learning Dependency Injection">
<link rel="part" href="reference.html" title="Part III. Zend Framework Reference">
<link rel="chapter" href="zend.acl.html" title="Chapter 3. Zend\Acl">
<link rel="chapter" href="zend.authentication.html" title="Chapter 4. Zend\Authentication">
<link rel="chapter" href="zend.barcode.html" title="Chapter 5. Zend\Barcode">
<link rel="chapter" href="zend.cache.html" title="Chapter 6. Zend\Cache">
<link rel="chapter" href="zend.captcha.html" title="Chapter 7. Zend\Captcha">
<link rel="chapter" href="zend.config.html" title="Chapter 8. Zend_Config">
<link rel="chapter" href="zend.crypt.html" title="Chapter 9. Zend_Crypt">
<link rel="chapter" href="zend.db.html" title="Chapter 10. Zend_Db">
<link rel="chapter" href="zend.di.html" title="Chapter 11. Zend\Di">
<link rel="chapter" href="zend.dom.html" title="Chapter 12. Zend\Dom">
<link rel="chapter" href="zend.event-manager.html" title="Chapter 13. Zend\EventManager">
<link rel="chapter" href="zend.form.html" title="Chapter 14. Zend_Form">
<link rel="chapter" href="zend.http.html" title="Chapter 15. Zend_Http">
<link rel="chapter" href="zend.i18n.html" title="Chapter 16. Zend_I18n">
<link rel="chapter" href="zend.input-filter.html" title="Chapter 17. Zend\InputFilter">
<link rel="chapter" href="zend.ldap.html" title="Chapter 18. Zend_Ldap">
<link rel="chapter" href="zend.loader.html" title="Chapter 19. Zend\Loader">
<link rel="refentry" href="zend.loader.autoloader-factory.methods.factory.html" title="factory">
<link rel="refentry" href="zend.loader.autoloader-factory.methods.get-registered-autoloaders.html" title="getRegisteredAutoloaders">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.add-static-map.html" title="addStaticMap">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.register-plugin.html" title="registerPlugin">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.register-plugins.html" title="registerPlugins">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.unregister-plugin.html" title="unregisterPlugin">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.get-registered-plugins.html" title="getRegisteredPlugins">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.is-loaded.html" title="isLoaded">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.get-class-name.html" title="getClassName">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.load.html" title="load">
<link rel="refentry" href="zend.loader.plugin-class-loader.methods.get-iterator.html" title="getIterator">
<link rel="refentry" href="zend.loader.short-name-locator.methods.is-loaded.html" title="isLoaded">
<link rel="refentry" href="zend.loader.short-name-locator.methods.get-class-name.html" title="getClassName">
<link rel="refentry" href="zend.loader.short-name-locator.methods.load.html" title="load">
<link rel="refentry" href="zend.loader.plugin-class-locator.methods.register-plugin.html" title="registerPlugin">
<link rel="refentry" href="zend.loader.plugin-class-locator.methods.unregister-plugin.html" title="unregisterPlugin">
<link rel="refentry" href="zend.loader.plugin-class-locator.methods.get-registered-plugins.html" title="getRegisteredPlugins">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.autoload.html" title="autoload">
<link rel="refentry" href="zend.loader.spl-autoloader.methods.register.html" title="register">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.register-autoload-map.html" title="registerAutoloadMap">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.register-autoload-maps.html" title="registerAutoloadMaps">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.get-autoload-map.html" title="getAutoloadMap">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.autoload.html" title="autoload">
<link rel="refentry" href="zend.loader.class-map-autoloader.methods.register.html" title="register">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.set-fallback-autoloader.html" title="setFallbackAutoloader">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.is-fallback-autoloader.html" title="isFallbackAutoloader">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-namespace.html" title="registerNamespace">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-namespaces.html" title="registerNamespaces">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-prefix.html" title="registerPrefix">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register-prefixes.html" title="registerPrefixes">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.autoload.html" title="autoload">
<link rel="refentry" href="zend.loader.standard-autoloader.methods.register.html" title="register">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.constructor.html" title="__construct">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.add-static-paths.html" title="addStaticPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.set-options.html" title="setOptions">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.add-prefix-path.html" title="addPrefixPath">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.add-prefix-paths.html" title="addPrefixPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-paths.html" title="getPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.clear-paths.html" title="clearPaths">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.remove-prefix-path.html" title="removePrefixPath">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.is-loaded.html" title="isLoaded">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-class-name.html" title="getClassName">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.load.html" title="load">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-plugin-map.html" title="getPluginMap">
<link rel="refentry" href="zend.loader.prefix-path-loader.methods.get-class-map.html" title="getClassMap">
<link rel="refentry" href="zend.loader.prefix-path-mapper.methods.add-prefix-path.html" title="addPrefixPath">
<link rel="refentry" href="zend.loader.prefix-path-mapper.methods.remove-prefix-path.html" title="removePrefixPath">
<link rel="chapter" href="zend.mail.html" title="Chapter 20. Zend\Mail">
<link rel="chapter" href="zend.module-manager.html" title="Chapter 21. Zend\ModuleManager">
<link rel="chapter" href="zend.mvc.html" title="Chapter 22. Zend\Mvc">
<link rel="chapter" href="zend.service-manager.html" title="Chapter 23. Zend\ServiceManager">
<link rel="chapter" href="zend.stdlib.html" title="Chapter 24. Zend\Stdlib">
<link rel="chapter" href="zend.uri.html" title="Chapter 25. Zend_Uri">
<link rel="chapter" href="zend.validator.html" title="Chapter 26. Zend\Validator">
<link rel="chapter" href="zend.view.html" title="Chapter 27. Zend_View">
<link rel="chapter" href="zend.xmlrpc.html" title="Chapter 28. Zend_XmlRpc">
<link rel="appendix" href="copyrights.html" title="Appendix A. Copyright Information">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader"><table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">14.2. Zend\Form Quick Start</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="zend.form.html">Prev</a> </td>
<th width="60%" align="center">Chapter 14. Zend_Form</th>
<td width="20%" align="right"> <a accesskey="n" href="zend.http.html">Next</a>
</td>
</tr>
</table></div>
<div class="section" title="14.2. Zend\Form Quick Start">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="zend.form.quick-start"></a>14.2. Zend\Form Quick Start</h2></div></div></div>
<p>
        Forms are relatively easy to create. At the bare minimum, each element or fieldset requires
        a name; typically, you'll also provide some attributes to hint to the view layer how it
        might render the item. The form itself will also typically compose an <code class="classname"><a class="classname" href="zend.input-filter.html" title="Chapter 17. Zend\InputFilter">InputFilter</a></code> -- which you can also conveniently
        create directly in the form via a factory. Individual elements can hint as to what defaults
        to use when generating a related input for the input filter.
    </p>
<p>
        Form validation is as easy as providing an array of data to the
        <code class="methodname">setData()</code> method. If you want to simplify your work even more, you
        can bind an object to the form; on successful validation, it will be populated from the
        validated values.
    </p>
<div class="example">
<a name="zend.form.quick-start.programmatic"></a><p class="title"><b>Example 14.1. Programmatic Form Creation</b></p>
<div class="example-contents">
<p>
            If nothing else, you can simply start creating elements, fieldsets, and forms and wiring
            them together.
        </p>
<pre class="programlisting">
use Zend\Captcha;
use Zend\Form\Element;
use Zend\Form\Fieldset;
use Zend\Form\Form;
use Zend\InputFilter\Input;
use Zend\InputFilter\InputFilter;

$name = new Element('name');
$name-&gt;setAttributes(array(
    'type'  =&gt; 'text',
    'label' =&gt; 'Your name',
));

$email = new Element('email');
$email-&gt;setAttributes(array(
    'type'  =&gt; 'email',
    'label' =&gt; 'Your email address',
));

$subject = new Element('subject');
$subject-&gt;setAttributes(array(
    'type'  =&gt; 'text',
    'label' =&gt; 'Subject',
));

$message = new Element('message');
$message-&gt;setAttributes(array(
    'type'  =&gt; 'textarea',
    'label' =&gt; 'Message',
));

$captcha = new Element\Captcha('captcha');
$captcha-&gt;setCaptcha(new Captcha\Dumb());
$captcha-&gt;setAttributes(array(
    'label' =&gt; 'Please verify you are human',
));

$csrf = new Element\Csrf('security');

$submit = new Element('send');
$submit-&gt;setAttributes(array(
    'type'  =&gt; 'submit',
    'label' =&gt; 'Send',
));


$form = new Form('contact');
$form-&gt;add($name);
$form-&gt;add($email);
$form-&gt;add($subject);
$form-&gt;add($message);
$form-&gt;add($captcha);
$form-&gt;add($csrf);
$form-&gt;add($send);

$nameInput = new Input('name');
// configure input... and all others
$inputFilter = new InputFilter();
// attach all inputs

$form-&gt;setInputFilter($inputFilter);
</pre>
<p>
            As a demonstration of fieldsets, let's alter the above slightly. We'll create two
            fieldsets, one for the sender information, and another for the message details.
        </p>
<pre class="programlisting">
$sender = new Fieldset('sender');
$sender-&gt;add($name);
$sender-&gt;add($email);

$details = new Fieldset('details');
$details-&gt;add($subject);
$details-&gt;add($message);

$form = new Form('contact');
$form-&gt;add($sender);
$form-&gt;add($details);
$form-&gt;add($captcha);
$form-&gt;add($csrf);
$form-&gt;add($send);
</pre>
<p>
            Regardles of approach, as you can see, this can be tedious.
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.factory"></a><p class="title"><b>Example 14.2. Creation via Factory</b></p>
<div class="example-contents">
<p>
            You can create the entire form, and input filter, using the
            <code class="classname">Factory</code>. This is particularly nice if you want to store your
            forms as pure configuration; you can simply pass the configuration to the factory and be
            done.
        </p>
<pre class="programlisting">
use Zend\Form\Factory;
$factory = new Factory();
$form    = $factory-&gt;createForm(array(
    'hydrator' =&gt; 'Zend\Stdlib\Hydrator\ArraySerializable'
    'elements' =&gt; array(
        array(
            'name' =&gt; 'name',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Your name',
            ),
        ),
        array(
            'name' =&gt; 'email',
            'attributes' =&gt; array(
                'type'  =&gt; 'email',
                'label' =&gt; 'Your email address',
            ),
        ),
        array(
            'name' =&gt; 'subject',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Subject',
            ),
        ),
        array(
            'name' =&gt; 'message',
            'attributes' =&gt; array(
                'type'  =&gt; 'textarea',
                'label' =&gt; 'Message',
            ),
        ),
        array(
            'type' =&gt; 'Zend\Form\Element\Captcha',
            'name' =&gt; 'captcha',
            'attributes' =&gt; array(
                'label' =&gt; 'Please verify you are human',
                'captcha =&gt; array(
                    'class' =&gt; 'Dumb',
                ),
            ),
        ),
        array(
            'type' =&gt; 'Zend\Form\Element\Csrf',
            'name' =&gt; 'security',
        ),
        array(
            'name' =&gt; 'send',
            'attributes' =&gt; array(
                'type'  =&gt; 'submit',
                'label' =&gt; 'Send',
            ),
        ),
    ),
    /* If we had fieldsets, they'd go here; fieldsets contain
     * "elements" and "fieldsets" keys, and potentially a "type"
     * key indicating the specific FieldsetInterface 
     * implementation to use.
    'fieldsets' =&gt; array(
    ),
     */

    // Configuration to pass on to 
    // Zend\InputFilter\Factory::createInputFilter()
    'input_filter' =&gt; array(
        /* ... */
    ),
));
</pre>
<p>
            If we wanted to use fieldsets, as we demonstrated in the previous example, we could do
            the following:
        </p>
<pre class="programlisting">
use Zend\Form\Factory;
$factory = new Factory();
$form    = $factory-&gt;createForm(array(
    'hydrator'  =&gt; 'Zend\Stdlib\Hydrator\ArraySerializable'
    'fieldsets' =&gt; array(
        array(
            'name' =&gt; 'sender',
            'elements' =&gt; array(
                array(
                    'name' =&gt; 'name',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'text',
                        'label' =&gt; 'Your name',
                    ),
                ),
                array(
                    'name' =&gt; 'email',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'email',
                        'label' =&gt; 'Your email address',
                    ),
                ),
            ),
        ),
        array(
            'name' =&gt; 'details',
            'elements' =&gt; array(
                array(
                    'name' =&gt; 'subject',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'text',
                        'label' =&gt; 'Subject',
                    ),
                ),
                array(
                    'name' =&gt; 'message',
                    'attributes' =&gt; array(
                        'type'  =&gt; 'textarea',
                        'label' =&gt; 'Message',
                    ),
                ),
            ),
        ),
    ),
    'elements' =&gt; array(
        array(
            'type' =&gt; 'Zend\Form\Element\Captcha',
            'name' =&gt; 'captcha',
            'attributes' =&gt; array(
                'label' =&gt; 'Please verify you are human',
                'captcha =&gt; array(
                    'class' =&gt; 'Dumb',
                ),
            ),
        ),
        array(
            'type' =&gt; 'Zend\Form\Element\Csrf',
            'name' =&gt; 'security',
        ),
        array(
            'name' =&gt; 'send',
            'attributes' =&gt; array(
                'type'  =&gt; 'submit',
                'label' =&gt; 'Send',
            ),
        ),
    ),

    // Configuration to pass on to 
    // Zend\InputFilter\Factory::createInputFilter()
    'input_filter' =&gt; array(
        /* ... */
    ),
));
</pre>
<p>
            Note that the chief difference is nesting; otherwise, the information is basically the
            same.
        </p>
<p>
            The chief benefits to using the <code class="classname">Factory</code> are allowing you to store
            definitions in configuration, and usage of significant whitespace.
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.extension"></a><p class="title"><b>Example 14.3. Factory-backed Form Extension</b></p>
<div class="example-contents">
<p>
            The default <code class="classname">Form</code> implementation is backed by the
            <code class="classname">Factory</code>. This allows you to extend it, and define your form
            internally. This has the benefit of allowing a mixture of programmatic and
            factory-backed creation, as well as defining a form for re-use in your application.
        </p>
<pre class="programlisting">
namespace Contact;

use Zend\Captcha\AdapterInterface as CaptchaAdapter;
use Zend\Form\Element;
use Zend\Form\Form;

class ContactForm extends Form
{
    protected $captcha;

    public function setCaptcha(CaptchaAdapter $captcha)
    {
        $this-&gt;captcha = $captcha;
    }

    public function prepareElements()
    {
        // add() can take either an Element/Fieldset instance, 
        // or a specification, from which the appropriate object
        // will be built.

        $this-&gt;add(array(
            'name' =&gt; 'name',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Your name',
            ),
        ));
        $this-&gt;add(array(
            'name' =&gt; 'email',
            'attributes' =&gt; array(
                'type'  =&gt; 'email',
                'label' =&gt; 'Your email address',
            ),
        ));
        $this-&gt;add(array(
            'name' =&gt; 'subject',
            'attributes' =&gt; array(
                'type'  =&gt; 'text',
                'label' =&gt; 'Subject',
            ),
        ));
        $this-&gt;add(array(
            'name' =&gt; 'message',
            'attributes' =&gt; array(
                'type'  =&gt; 'textarea',
                'label' =&gt; 'Message',
            ),
        ));
        $this-&gt;add(array(
            'type' =&gt; 'Zend\Form\Element\Captcha',
            'name' =&gt; 'captcha',
            'attributes' =&gt; array(
                'label' =&gt; 'Please verify you are human',
                'captcha =&gt; $this-&gt;captcha,
            ),
        )),
        $this-&gt;add(new Element\Csrf('security'));
        $this-&gt;add(array(
            'name' =&gt; 'send',
            'attributes' =&gt; array(
                'type'  =&gt; 'submit',
                'label' =&gt; 'Send',
            ),
        ));

        // We could also define the input filter here, or
        // lazy-create it in the getInputFilter() method.
    }
));
</pre>
<p>
            You'll note that this example introduces a method,
            <code class="methodname">prepareElements()</code>. This is done to allow altering and/or
            configuring either the form or input filter factory instances, which could then have
            bearing on how elements, inputs, etc. are created. In this case, it also allows
            injection of the CAPTCHA adapter, allowing us to configure it elsewhere in our
            application and inject it into the form.
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.validation"></a><p class="title"><b>Example 14.4. Validating Forms</b></p>
<div class="example-contents">
<p>
            Validating forms requires three steps. First, the form must have an input filter
            attached. Second, you must inject the data to validate into the form. Third, you
            validate the form. If invalid, you can retrieve the error messages, if any.
        </p>
<pre class="programlisting">
$form = new Contact\ContactForm();

// If the form doesn't define an input filter by default, inject one.
$form-&gt;setInputFilter(new Contact\ContactFilter());

// Get the data. In an MVC application, you might try:
$data = $request-&gt;post();  // for POST data
$data = $request-&gt;query(); // for GET (or query string) data

$form-&gt;setData($data);

// Validate the form
if ($form-&gt;isValid() {
    $validatedData = $form-&gt;getData();
} else {
    $messages = $form-&gt;getMessages();
}
</pre>
<p>
            You can get the raw data if you want, by accessing the composed input filter.
        </p>
<pre class="programlisting">
$filter = $form-&gt;getInputFilter();

$rawValues    = $filter-&gt;getRawValues();
$nameRawValue = $filter-&gt;getRawValue('name');
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.input-specification"></a><p class="title"><b>Example 14.5. Hinting to the Input Filter</b></p>
<div class="example-contents">
<p>
            Often, you'll create elements that you expect to behave in the same way on each usage,
            and for which you'll want specific filters or validation as well. Since the input filter
            is a separate object, how can you achieve these latter points?
        </p>
<p>
            Because the default form implementation composes a factory, and the default factory
            composes an input filter factory, you can have your elements and/or fieldsets hint to
            the input filter. If no input or input filter is provided in the input filter for that
            element, these hints will be retrieved and used to create them.
        </p>
<p>
            To do so, one of the following must occur. For elements, they must implement
            <code class="classname">Zend\InputFilter\InputProviderInterface</code>, which defines a
            <code class="methodname">getInputSpecification()</code> method; for fieldsets, they must
            implement <code class="classname">Zend\InputFilter\InputFilterProviderInterface</code>, which
            defines a <code class="methodname">getInputFilterSpecification()</code> method.
        </p>
<p>
            In the case of an element, the <code class="methodname">getInputSpecification()</code> method
            should return data to be used by the input filter factory to create an input.
        </p>
<pre class="programlisting">
namespace Contact\Form;

use Zend\Form\Element;
use Zend\InputFilter\InputProviderInterface;
use Zend\Validator;

class EmailElement extends Element implements InputProviderInterface
{
    protected $attributes = array(
        'type' =&gt; 'email',
    );

    public function getInputSpecification()
    {
        return array(
            'name'     =&gt; $this-&gt;getName(),
            'required' =&gt; true,
            'filters'  =&gt; array(
                array('name' =&gt; 'Zend\Filter\StringTrim'),
            ),
            'validators' =&gt; array(
                new Validator\Email(),
            ),
        );
    }
}
</pre>
<p>
            The above would hint to the input filter to create and attach an input named after the
            element, marking it as required, and giving it a <code class="classname">StringTrim</code>
            filter and an <code class="classname">Email</code> validator. Note that you can either rely on
            the input filter to create filters and validators, or directly instantiate them.
        </p>
<p>
            For fieldsets, you do very similarly; the difference is that
            <code class="methodname">getInputFilterSpecification()</code> must return configuration for an
            input filter.
        </p>
<pre class="programlisting">
namespace Contact\Form;

use Zend\Form\Fieldset;
use Zend\InputFilter\InputFilterProviderInterface;

class SenderFieldset extends Fieldset implements InputFilterProviderInterface
{
    public function getInputFilterSpecification()
    {
        return array(
            'name' =&gt; array(
                'required' =&gt; true,
                'filters'  =&gt; array(
                    array('name' =&gt; 'Zend\Filter\StringTrim'),
                ),
            ),
            'email' =&gt; array(
                'required' =&gt; true,
                'filters'  =&gt; array(
                    array('name' =&gt; 'Zend\Filter\StringTrim'),
                ),
                'validators' =&gt; array(
                    new Validator\Email(),
                ),
            ),
        );
    }
}
</pre>
<p>
            Specifications are a great way to make forms, fieldsets, and elements re-usable
            trivially in your applications. In fact, the <code class="classname">Captcha</code> and
            <code class="classname">Csrf</code> elements define specifications in order to ensure they can
            work without additional user configuration!
        </p>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.binding"></a><p class="title"><b>Example 14.6. Binding an object</b></p>
<div class="example-contents">
<p>
            As noted in the intro, forms in Zend Framework bridge the domain model and the view
            layer. Let's see that in action.
        </p>
<p>
            When you <code class="methodname">bind()</code> an object to the form, the following happens:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    The composed <code class="classname">Hydrator</code> calls
                    <code class="methodname">extract()</code> on the object, and uses the values returned,
                    if any, to populate the <code class="varname">value</code> attributes of all elements.
                </p></li>
<li class="listitem"><p>
                    When <code class="methodname">isValid()</code> is called, if
                    <code class="methodname">setData()</code> has not been previously set, the form uses
                    the composed <code class="classname">Hydrator</code> to extract values from the object,
                    and uses those during validation.
                </p></li>
<li class="listitem"><p>
                    If <code class="methodname">isValid()</code> is successful (and the
                    <code class="varname">bindOnValidate</code> flag is enabled, which is true by default),
                    then the <code class="classname">Hydrator</code> will be passed the validated values to
                    use to hydrate the bound object. (If you do not want this behavior, call
                    <code class="methodname">setBindOnValidate(FormInterface::BIND_MANUAL)</code>).
                </p></li>
<li class="listitem"><p>
                    If the object implements
                    <code class="classname">Zend\InputFilter\InputFilterAwareInterface</code>, the input
                    filter it composes will be used instead of the one composed on the form.
                </p></li>
</ul></div>
<p>
            This is easier to understand in practice.
        </p>
<pre class="programlisting">
$contact = new ArrayObject;
$contact['subject'] = '[Contact Form] ';
$contact['message'] = 'Type your message here';

$form    = new Contact\ContactForm;

$form-&gt;bind($contact); // form now has default values for 
                       // 'subject' and 'message'

$data = array(
    'name'    =&gt; 'John Doe',
    'email'   =&gt; 'j.doe@example.tld',
    'subject' =&gt; '[Contact Form] \'sup?',
);
$form-&gt;setData($data);

if ($form-&gt;isValid()) {
    // $contact now looks like:
    // array(
    //     'name'    =&gt; 'John Doe',
    //     'email'   =&gt; 'j.doe@example.tld',
    //     'subject' =&gt; '[Contact Form] \'sup?',
    //     'message' =&gt; 'Type your message here',
    // )
    // only as an ArrayObject
}
</pre>
<p>
            When an object is bound to the form, calling <code class="methodname">getData()</code> will
            return that object by default. If you want to return an associative array instead, you
            can pass the <code class="varname">FormInterface::VALUES_AS_ARRAY</code> flag to the method.
        </p>
<pre class="programlisting">
use Zend\Form\FormInterface;
$data = $form-&gt;getData(FormInterface::VALUES_AS_ARRAY);
</pre>
<p>
            Zend Framework ships several standard <a class="link" href="zend.stdlib.html#zend.stdlib.hydrator" title="24.1. Zend\Stdlib\Hydrator">hydrators</a>, and implementation is as simple as
            implementing <code class="classname">Zend\Stdlib\Hydrator\HydratorInterface</code>, which looks
            like this:
        </p>
<pre class="programlisting">
namespace Zend\Stdlib\Hydrator;

interface Hydrator
{
    /** @return array */
    public function extract($object);
    public function hydrate(array $data, $object);
}
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.rendering"></a><p class="title"><b>Example 14.7. Rendering</b></p>
<div class="example-contents">
<p>
            As noted previously, forms are meant to bridge the domain model and view layer. We've
            discussed the domain model binding, but what about the view?
        </p>
<p>
            The form component ships a set of form-specific view helpers. These accept the various
            form objects, and introspect them in order to generate markup. Typically, they will
            inspect the attributes, but in special cases, they may look at other properties and
            composed objects.
        </p>
<p>
            When preparing to render, you will likely want to call
            <code class="methodname">prepare()</code>. This method ensures that certain injections are
            done, and will likely in the future munge names to allow for
            <code class="varname">scoped[array][notation]</code>.
        </p>
<p>
            The most used and simplest view helpers available are
            <code class="classname">Form</code>, <code class="classname">FormElement</code>,
            <code class="classname">FormLabel</code>, and <code class="classname">FormElementErrors</code>. Let's
            use them to display the contact form.
        </p>
<pre class="programlisting">
&lt;?php
// within a view script
$form = $this-&gt;form;
$form-&gt;prepare();

// Assuming the "contact/process" route exists...
$form-&gt;setAttribute('action', $this-&gt;url('contact/process'));

// Set the method attribute for the form
$form-&gt;setAttribute('method', 'post');

// Get the form label plugin
$formLabel = $this-&gt;plugin('formLabel');
 
// Render the opening tag
echo $this-&gt;form()-&gt;openTag($form);
?&gt;
&lt;div class="form_element"&gt;
&lt;?php 
    $name = $form-&gt;get('name');
    echo $formLabel-&gt;openTag() . $name-&gt;getAttribute('label');
    echo $this-&gt;formInput($name);
    echo $this-&gt;formElementErrors($name);
    echo $formLabel-&gt;closeTag();
?&gt;&lt;/div&gt;
 
&lt;div class="form_element"&gt;
&lt;?php 
    $subject = $form-&gt;get('subject');
    echo $formLabel-&gt;openTag() . $subject-&gt;getAttribute('label');
    echo $this-&gt;formInput($subject);
    echo $this-&gt;formElementErrors($subject);
    echo $formLabel-&gt;closeTag();
?&gt;&lt;/div&gt;
 
&lt;div class="form_element"&gt;
&lt;?php 
    $message = $form-&gt;get('message');
    echo $formLabel-&gt;openTag() . $message-&gt;getAttribute('label');
    echo $this-&gt;formInput($message);
    echo $this-&gt;formElementErrors($message);
    echo $formLabel-&gt;closeTag();
?&gt;&lt;/div&gt;
 
&lt;div class="form_element"&gt;
&lt;?php 
    $captcha = $form-&gt;get('captcha');
    echo $formLabel-&gt;openTag() . $captcha-&gt;getAttribute('label');
    echo $this-&gt;formInput($captcha);
    echo $this-&gt;formElementErrors($captcha);
    echo $formLabel-&gt;closeTag();
?&gt;&lt;/div&gt;

&lt;?php echo $this-&gt;formElement($form-&gt;get('security') ?&gt;
&lt;?php echo $this-&gt;formElement($form-&gt;get('send') ?&gt;
 
&lt;?php echo $this-&gt;form()-&gt;closeTag() ?&gt;
</pre>
<p>
            There are a few things to note about this. First, to prevent confusion in IDEs and
            editors when syntax highlighting, we use helpers to both open and close the form and
            label tags. Second, there's a lot of repetition happening here; we could easily create a
            partial view script or a composite helper to reduce boilerplate. Third, note that not
            all elements are created equal -- the CSRF and submit elements don't need labels or
            error messages necessarily. Finally, note that the <code class="classname">FormElement</code>
            helper tries to do the right thing -- it delegates actual markup generation toother view
            helpers; however, it can only guess what specific form helper to delegate to based on
            the list it has. If you introduce new form view helpers, you'll need to extend the
            <code class="classname">FormElement</code> helper, or create your own.
        </p>
<p>
            Currently, the complete list of available form helpers is:
            <code class="classname">FormCaptcha</code>, 
            <code class="classname">FormInput</code> (which handles any type that the input HTML element
            accepts), <code class="classname">FormMultiCheckbox</code> (for creating sets of related
            checkboxes), <code class="classname">FormRadio</code>, <code class="classname">FormSelect</code>
            (which can also handle optgroups), and <code class="classname">FormTextarea</code>.
        </p>
<p>
            In order to use these form view helpers in the first place, you need to inform the
            helper loader about them. The easiest way to do this is in your configuration; simply
            add an entry for <code class="classname">Zend\Form\View\HelperLoader</code> to the
            <code class="varname">helper_map</code> key of the <code class="varname">view_manager</code> configuration:
        </p>
<pre class="programlisting">
// In some module configuration, or a config/autoload/ configuration file:
return array(
    'view_manager' =&gt; array(
        'helper_map' =&gt; array(
            'Zend\Form\View\HelperLoader,
        ),
    ),
);
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.partial"></a><p class="title"><b>Example 14.8. Validation Groups</b></p>
<div class="example-contents">
<p>
            Sometimes you want to validate only a subset of form elements. As an example, let's say
            we're re-using our contact form over a web service; in this case, the
            <code class="classname">Csrf</code>, <code class="classname">Captcha</code>, and submit button elements
            are not of interest, and shouldn't be validated.
        </p>
<p>
            <code class="classname">Zend\Form</code> provides a proxy method to the underlying
            <code class="classname">InputFilter</code>'s <code class="methodname">setValidationGroup()</code>
            method, allowing us to perform this operation.
        </p>
<pre class="programlisting">
$form-&gt;setValidationGroup('name', 'email', 'subject', 'message');
$form-&gt;setData($data);
if ($form-&gt;isValid()) {
    // Contains only the "name", "email", "subject", and "message" values
    $data = $form-&gt;getData();
}
</pre>
<p>
            If you later want to reset the form to validate all, simply pass the
            <code class="varname">FormInterface::VALIDATE_ALL</code> flag to the
            <code class="methodname">setValidationGroup()</code> method.
        </p>
<pre class="programlisting">
use Zend\Form\FormInterface;
$form-&gt;setValidationGroup(FormInterface::VALIDATE_ALL);
</pre>
</div>
</div>
<br class="example-break"><div class="example">
<a name="zend.form.quick-start.annotations"></a><p class="title"><b>Example 14.9. Using Annotations</b></p>
<div class="example-contents">
<p>
            Creating a complete forms solution can often be tedious: you'll create some domain model
            object, an input filter for validating it, a form object for providing a representation
            for it, and potentially a hydrator for mapping the form elements and fieldsets to the
            domain model. Wouldn't it be nice to have a central place to define all of these?
        </p>
<p>
            Annotations allow us to solve this problem. You can define the following behaviors with
            the shipped annotations in <code class="classname">Zend\Form</code>:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem"><p>
                    <code class="code">AllowEmpty</code>: mark an input as allowing an empty value. This
                    annotation does not require a value.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Attributes</code>: specify the form, fieldset, or element attributes. This
                    annotation requires an associative array of values, in a JSON object format:
                    <code class="code">@Attributes({"class":"zend_form","type":"text"})</code>.
                </p></li>
<li class="listitem"><p>
                    <code class="code">ComposedObject</code>: specify another object with annotations to parse.
                    Typically, this is used if a property references another object, which will then
                    be added to your form as an additional fieldset. Expects a string value
                    indicating the class for the object being composed.
                </p></li>
<li class="listitem"><p>
                    <code class="code">ErrorMessage</code>: specify the error message to return for an element in
                    the case of a failed validation. Expects a string value.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Exclude</code>: mark a property to exclude from the form or fieldset. This
                    annotation does not require a value.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Filter</code>: provide a specification for a filter to use on a given
                    element. Expects an associative array of values, with a "name" key pointing to a
                    string filter name, and an "options" key pointing to an associatve array of
                    filter options for the constructor: <code class="code">@Filter({"name": "Boolean", "options":
                        {"casting":true}})</code>. This annotation may be specified multiple times.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Flags</code>: flags to pass to the fieldset or form composing an element
                    or fieldset; these are usually used to specify the name or priority. The
                    annotation expects an associative array: <code class="code">@Flags({"priority": 100})</code>.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Hydrator</code>: specify the hydrator class to use for this given form or
                    fieldset. A string value is expected.
                </p></li>
<li class="listitem"><p>
                    <code class="code">InputFilter</code>: specify the input filter class to use for this given
                    form or fieldset. A string value is expected.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Input</code>: specify the input class to use for this given element. A
                    string value is expected.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Name</code>: specify the name of the current element, fieldset, or form. A
                    string value is expected.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Options</code>: options to pass to the fieldset or form that are used to
                    inform behavior -- things that are not attributes; e.g. labels, CAPTCHA
                    adapters, etc. The annotation expects an associative array: 
                    <code class="code">@Options({"label": "Username:"})</code>.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Required</code>: indicate whether an element is required. A boolean value
                    is expected. By default, all elements are required, so this annotation is mainly
                    present to allow disabling a requirement.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Type</code>: indicate the class to use for the current element, fieldset,
                    or form. A string value is expected.
                </p></li>
<li class="listitem"><p>
                    <code class="code">Validator</code>: provide a specification for a validator to use on a given
                    element. Expects an associative array of values, with a "name" key pointing to a
                    string validator name, and an "options" key pointing to an associatve array of
                    validator options for the constructor: <code class="code">@Validator({"name": "StringLength", "options":
                        {"min":3, "max": 25}})</code>. This annotation may be specified multiple times.
                </p></li>
</ul></div>
<p>
            To use annotations, you simply include them in your class and/or property docblocks.
            Annotation names will be resolved according to the import statements in your class; as
            such, you can make them as long or as short as you want depending on what you import.
        </p>
<p>
            Here's a simple example.
        </p>
<pre class="programlisting">
use Zend\Form\Annotation;

/**
 * @Annotation\Name("user")
 * @Annotation\Hydrator("Zend\Stdlib\Hydrator\ObjectProperty")
 */
class User
{
    /**
     * @Annotation\Exclude()
     */
    public $id;

    /**
     * @Annotation\Filter({"name":"StringTrim"})
     * @Annotation\Validator({"name":"StringLength", "options":{"min":1, "max":25}})
     * @Annotation\Validator({"name":"Regex", "options":{"pattern":"/^[a-zA-Z][a-zA-Z0-9_-]{0,24}$/"}})
     * @Annotation\Attributes({"type":"text"})
     * @Annotation\Options({"label":"Username:"})
     */
    public $username;

    /**
     * @Annotation\Type("Zend\Form\Element\Email")
     * @Annotation\Options({"label":"Your email address:"})
     */
    public $email;
}
</pre>
<p>
            The above will hint to the annotation build to create a form with name "user", which
            uses the hydrator <code class="classname">Zend\Stdlib\Hydrator\ObjectProperty</code>. That form
            will have two elements, "username" and "email". The "username" element will have an
            associated input that has a <code class="classname">StringTrim</code> filter, and two
            validators: a <code class="classname">StringLength</code> validator indicating the username is
            between 1 and 25 characters, and a <code class="classname">Regex</code> validator asserting it
            follows a specific accepted pattern. The form element itself will have an attribute
            "type" with value "text" (a text element), and a label "Username:". The "email" element
            will be of type <code class="classname">Zend\Form\Element\Email</code>, and have the label "Your
            email address:".
        </p>
<p>
            To use the above, we need <code class="classname">Zend\Form\Annotation\AnnotationBuilder</code>:
        </p>
<pre class="programlisting">
use Zend\Form\Annotation\AnnotationBuilder;

$builder = new AnnotationBuilder();
$form    = $builder-&gt;createForm('User');
</pre>
<p>
            At this point, you have a form with the appropriate hydrator attached, an input filter
            with the appropriate inputs, and all elements.
        </p>
<div class="note" title="You're not done"><table border="0" summary="Note: You're not done">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td>
<th align="left">You're not done</th>
</tr>
<tr><td align="left" valign="top"><p>
                In all liklihood, you'll need to add some more elements to the form you construct.
                For example, you'll want a submit button, and likely a CSRF-protection element. We
                recommend creating a fieldset with common elements such as these that you can then
                attach to the form you build via annotations.
            </p></td></tr>
</table></div>
</div>
</div>
<br class="example-break">
</div>
<div class="navfooter"><table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="zend.form.html">Prev</a> </td>
<td width="20%" align="center"><a accesskey="u" href="zend.form.html">Up</a></td>
<td width="40%" align="right"> <a accesskey="n" href="zend.http.html">Next</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter 14. Zend_Form </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top"> Chapter 15. Zend_Http</td>
</tr>
</table></div>
<div class="revinfo"></div>
</body>
</html>
